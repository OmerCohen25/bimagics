<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>转  砖专转</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        canvas {
            background-color: #0c0c1c;
            display: block;
            touch-action: none;
        }
        .screen {
            position: absolute;
            text-align: center;
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        h1 { font-size: 2.5em; margin-bottom: 0.5em; }
        p { font-size: 1.2em; line-height: 1.5; }
        button {
            font-size: 1.5em;
            padding: 10px 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 1em;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="screen">
        <h1>转  砖专转</h1>
        <p>
             专,  拽 转专!<br>
            砖 转, 住祝 砖拽 砖 专 爪!
        </p>
        <button id="startButton">转 砖拽</button>
    </div>

    <div id="gameOverScreen" class="screen" style="display:none;">
        <h1>砖拽 专</h1>
        <p>拽 住驻: <span id="finalScore">0</span></p>
        <p>砖: <span id="finalLevel">0</span></p>
        <button id="restartButton">砖拽 砖</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
    // ==================
    // 专转 转
    // ==================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let gameState = 'start';
    let score = 0;
    let level = 1;
    let lives = 3;
    let gameFrame = 0;
    let isBossLevel = false;
    let boss = null;
    let screenShake = { intensity: 0, duration: 0 };

    // 注专 住 拽
    let playerProjectiles = [], enemies = [], powerUps = [], explosions = [], stars = [], enemyProjectiles = [];
    
    // ==================
    //  住 (注 住 )
    // ==================
    const audioManager = {
        sounds: {},
        init() {
            this.sounds.shoot = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU9vT19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.explosion = new Audio("data:audio/wav;base64,UklGRkAIAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=");
            this.sounds.powerup = new Audio("data:audio/wav;base64,UklGRlphV19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUxhV19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.playerHit = new Audio("data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQBIAAA=");
            this.sounds.laser = new Audio("data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAIAIBAAAEEAAAEABAAgZGF0YQEcAAA=");
            Object.values(this.sounds).forEach(sound => {
                sound.volume = 0.5;
            });
            this.sounds.shoot.volume = 0.3;
        },
        play(name) {
            if (this.sounds[name]) {
                this.sounds[name].currentTime = 0;
                this.sounds[name].play().catch(e => {}); // 注 砖  砖转砖 注  抓
            }
        }
    };
    audioManager.init();

    // ==================
    // 拽住 (转转 拽)
    // ==================

    class Player {
        constructor() {
            this.width = 50; this.height = 50;
            this.x = canvas.width / 2 - this.width / 2;
            this.y = canvas.height - this.height - 20;
            this.weaponType = 'default'; // 'default', 'spread', 'laser'
            this.powerUpLevel = 1;
            this.shootCooldown = 0;
            this.isInvincible = false;
            this.invincibilityTimer = 0;
        }

        update(input) {
            if (input.x) this.x = input.x - this.width / 2;
            if (this.x < 0) this.x = 0;
            if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;

            if (this.shootCooldown > 0) this.shootCooldown--;
            this.shoot();

            if(this.isInvincible) {
                this.invincibilityTimer--;
                if(this.invincibilityTimer <= 0) this.isInvincible = false;
            }
        }

        draw() {
            if (this.isInvincible && gameFrame % 10 < 5) return; // 驻拽 
            ctx.font = '40px Arial';
            ctx.fillText('', this.x, this.y + this.height - 10);
        }

        shoot() {
            if (this.shootCooldown > 0) return;
            switch (this.weaponType) {
                case 'laser':
                    playerProjectiles.push(new Projectile(this.x + this.width / 2, this.y, 0, 'laser'));
                    audioManager.play('laser');
                    this.shootCooldown = 3; // 专 专 
                    break;
                case 'spread':
                    for(let i = 0; i < this.powerUpLevel + 1; i++) {
                         playerProjectiles.push(new Projectile(this.x + this.width / 2 - 5, this.y, i - (this.powerUpLevel)/2 , 'default'));
                    }
                    audioManager.play('shoot');
                    this.shootCooldown = 20 - this.powerUpLevel;
                    break;
                case 'default':
                default:
                    const bullets = Math.min(3, this.powerUpLevel); // 注 3 拽注
                    for(let i=0; i<bullets; i++) {
                       playerProjectiles.push(new Projectile(this.x + this.width/2 - 15 + (i*15), this.y-i*5, 0, 'default'));
                    }
                    audioManager.play('shoot');
                    this.shootCooldown = 15 - this.powerUpLevel;
                    break;
            }
        }
        
        takeHit() {
            if (this.isInvincible) return;
            lives--;
            audioManager.play('playerHit');
            triggerScreenShake(10, 30);
            this.isInvincible = true;
            this.invincibilityTimer = 120; // 2 砖转 砖 住转
            this.powerUpLevel = 1;
            this.weaponType = 'default';
            if (lives <= 0) endGame();
        }
    }

    class Projectile {
        constructor(x, y, speedX = 0, type = 'default') {
            this.x = x; this.y = y; this.type = type;
            if (type === 'laser') {
                this.width = 5 + player.powerUpLevel * 2; this.height = y;
                this.x -= this.width / 2;
                this.damage = 0.2 + player.powerUpLevel * 0.1;
                this.lifespan = 2; // 砖专 -2 驻专
            } else {
                this.width = 10; this.height = 15;
                this.speedY = 12; this.speedX = speedX * 2;
                this.damage = 1;
            }
        }
        update() {
            if (this.type === 'laser') {
                this.lifespan--;
            } else {
                this.y -= this.speedY; this.x += this.speedX;
            }
        }
        draw() {
            if (this.type === 'laser') {
                ctx.fillStyle = `rgba(100, 255, 255, ${0.5 + Math.random() * 0.5})`;
                ctx.fillRect(this.x, 0, this.width, this.y);
            } else {
                ctx.font = '20px Arial';
                ctx.fillText('', this.x, this.y);
            }
        }
    }
    
    class EnemyProjectile {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.width = 25; this.height = 25;
            this.speedY = 4 + level * 0.1;
        }
        update() { this.y += this.speedY; }
        draw() {
            ctx.font = '25px Arial';
            ctx.fillText('', this.x, this.y);
        }
    }

    const enemyTypes = {
        normal: { health: 1, size: 40, emoji: '', points: 10, shootCooldown: 150 },
        tough: { health: 5, size: 50, emoji: '', points: 50, shootCooldown: 120 },
        bomber: { health: 2, size: 45, emoji: '', points: 30, shootCooldown: 80 },
        boss: { health: 100, size: 120, emoji: '', points: 1000, shootCooldown: 40 }
    };

    class Enemy {
        constructor(x, y, type) {
            const proto = enemyTypes[type];
            this.x = x; this.y = y; this.type = type;
            this.width = proto.size; this.height = proto.size;
            this.maxHealth = proto.health + Math.floor(level/2); // 住 转拽 注 砖
            this.health = this.maxHealth;
            this.emoji = proto.emoji;
            this.points = proto.points;
            this.speedY = 1 + Math.random() * 1.5 + level * 0.1;
            this.shootTimer = Math.random() * proto.shootCooldown;
            this.shootCooldown = proto.shootCooldown;
        }
        update() {
            this.y += this.speedY;
            this.shootTimer--;
            if (this.shootTimer <= 0) {
                this.shoot();
                this.shootTimer = this.shootCooldown - level;
            }
        }
        draw() {
            ctx.font = `${this.width}px Arial`;
            ctx.fillText(this.emoji, this.x, this.y);
            //    砖专砖 转专 
            if(this.maxHealth > 1) {
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x, this.y - 15, this.width, 10);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x, this.y - 15, this.width * (this.health/this.maxHealth), 10);
            }
        }
        shoot() {
            if (this.type === 'boss') {
                // 专 驻专
                for(let i=-2; i<=2; i++){
                    enemyProjectiles.push(new EnemyProjectile(this.x + this.width/2 + (i*20), this.y + this.height));
                }
            } else {
               enemyProjectiles.push(new EnemyProjectile(this.x + this.width/2, this.y + this.height));
            }
        }
        takeDamage(amount) {
            this.health -= amount;
            return this.health <= 0;
        }
    }
    
    const powerUpTypes = {
        weapon_spread: { emoji: 'S', color: '#33ff33'},
        weapon_laser: { emoji: 'L', color: '#33ccff'},
        health_up: { emoji: '+', color: '#ff3333'}
    };

    class PowerUp {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.width = 30; this.height = 30;
            this.speedY = 2;
        }
        update() { this.y += this.speedY; }
        draw() {
            const proto = powerUpTypes[this.type];
            ctx.font = 'bold 30px Arial';
            ctx.fillStyle = proto.color;
            ctx.fillText(proto.emoji, this.x, this.y);
        }
    }
    
    class Explosion {
        constructor(x, y, size) {
            this.x = x; this.y = y; this.size = size;
            this.timer = 0; this.maxTimer = 10;
        }
        update() { this.timer++; }
        draw() {
            ctx.font = `${this.size * (1 - this.timer/this.maxTimer)}px Arial`;
            ctx.fillText('', this.x, this.y);
        }
    }

    class Star {
        constructor() {
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.size = Math.random() * 2 + 1;
            this.speed = Math.random() * 1 + 0.5;
        }
        update() {
            this.y += this.speed;
            if (this.y > canvas.height) {
                this.y = 0;
                this.x = Math.random() * canvas.width;
            }
        }
        draw() {
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    // ==================
    //  拽 (注专 注)
    // ==================
    const input = { x: canvas.width / 2, y: canvas.height - 60 };
    window.addEventListener('mousemove', e => { if (gameState === 'playing') input.x = e.clientX; });
    window.addEventListener('touchmove', e => {
        e.preventDefault();
        if (gameState === 'playing' && e.touches.length > 0) input.x = e.touches[0].clientX;
    }, { passive: false });


    // ==================
    // 驻拽爪转  砖拽
    // ==================
    const player = new Player();

    function initStars() {
        for(let i=0; i<100; i++) stars.push(new Star());
    }

    function handleStars() {
        stars.forEach(s => { s.update(); s.draw(); });
    }

    function spawnWave() {
        if (isBossLevel) return;

        // 拽  爪专 转 砖 住
        if (level % 5 === 0 && enemies.length === 0) {
            isBossLevel = true;
            boss = new Enemy(canvas.width/2 - 60, -150, 'boss');
            enemies.push(boss);
            return;
        }
        
        if (gameFrame % (Math.max(20, 100 - level * 3)) === 0) {
             let x = Math.random() * (canvas.width - 50);
             let y = -50;
             let enemyType = 'normal';
             let rand = Math.random();
             if (level > 2 && rand < 0.3) enemyType = 'tough';
             if (level > 3 && rand < 0.6) enemyType = 'bomber';
             enemies.push(new Enemy(x, y, enemyType));
        }
    }

    function handleGameObjects(arr) {
        for (let i = arr.length - 1; i >= 0; i--) {
            arr[i].update();
            arr[i].draw();
            // 拽转 拽 砖爪 住
            if (arr[i].y > canvas.height + 50 || arr[i].y < -50 || (arr[i].lifespan && arr[i].lifespan <= 0)) {
                arr.splice(i, 1);
            }
        }
    }

    function detectCollisions() {
        // 转砖转 拽注 砖拽 
        for (let i = enemies.length - 1; i >= 0; i--) {
            for (let j = playerProjectiles.length - 1; j >= 0; j--) {
                const enemy = enemies[i];
                const projectile = playerProjectiles[j];
                if (!enemy || !projectile) continue;

                if (projectile.x < enemy.x + enemy.width && projectile.x + projectile.width > enemy.x &&
                    projectile.y < enemy.y + enemy.height && projectile.y + projectile.height > enemy.y) 
                {
                    if (projectile.type !== 'laser') playerProjectiles.splice(j, 1);
                    
                    if(enemy.takeDamage(projectile.damage)) {
                        explosions.push(new Explosion(enemy.x, enemy.y, enemy.width));
                        audioManager.play('explosion');
                        triggerScreenShake(enemy.width * 0.1, 15);
                        score += enemy.points;

                        // 住 驻转 砖专
                        if (Math.random() < 0.15) {
                            const powerUpKeys = Object.keys(powerUpTypes);
                            const randomType = powerUpKeys[Math.floor(Math.random() * powerUpKeys.length)];
                            powerUps.push(new PowerUp(enemy.x, enemy.y, randomType));
                        }

                        if (isBossLevel && enemy.type === 'boss') {
                            isBossLevel = false;
                            boss = null;
                            level++;
                            score += 5000; // 住 
                        }
                        
                        enemies.splice(i, 1);

                        // 拽转 注转 砖 ( 砖 住)
                        if (!isBossLevel && score > level * 500) {
                            level++;
                        }
                        break;
                    }
                }
            }
        }
        
        // 转砖转 /爪 砖拽
        const entitiesToTest = [...enemies, ...enemyProjectiles];
        for (let i = entitiesToTest.length - 1; i >= 0; i--) {
             const entity = entitiesToTest[i];
             if (entity &&
                 player.x < entity.x + entity.width && player.x + player.width > entity.x &&
                 player.y < entity.y + entity.height && player.y + player.height > entity.y)
             {
                 player.takeHit();
                 //  转砖 爪, 住专 转.  ,  砖  .
                 if(entity instanceof EnemyProjectile) {
                    enemyProjectiles.splice(enemyProjectiles.indexOf(entity), 1);
                 } else {
                    explosions.push(new Explosion(entity.x, entity.y, entity.width));
                    enemies.splice(enemies.indexOf(entity), 1);
                 }
             }
        }

        // 转砖转 砖拽 注 砖专
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];
            if (powerUp && player.x < powerUp.x + powerUp.width && player.x + player.width > powerUp.x &&
                player.y < powerUp.y + powerUp.height && player.y + player.height > powerUp.y)
            {
                audioManager.play('powerup');
                switch(powerUp.type) {
                    case 'health_up':
                        if (lives < 5) lives++;
                        break;
                    case 'weapon_spread':
                    case 'weapon_laser':
                        player.weaponType = powerUp.type.split('_')[1];
                        player.powerUpLevel = 1;
                        break;
                }
                if (player.weaponType !== 'default' && powerUp.type.includes(player.weaponType)) {
                    if (player.powerUpLevel < 5) player.powerUpLevel++;
                }
                
                powerUps.splice(i, 1);
                score += 50;
            }
        }
    }
    
    function triggerScreenShake(intensity, duration) {
        screenShake.intensity = intensity;
        screenShake.duration = duration;
    }

    function applyScreenShake() {
        if (screenShake.duration > 0) {
            const dx = (Math.random() - 0.5) * screenShake.intensity;
            const dy = (Math.random() - 0.5) * screenShake.intensity;
            ctx.translate(dx, dy);
            screenShake.duration--;
        } else {
            screenShake.intensity = 0;
        }
    }

    function drawUI() {
        ctx.fillStyle = 'white'; ctx.font = '20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`拽: ${score}`, 10, 30);
        ctx.fillText(`砖: ${level}`, 10, 60);
        let weaponName = player.weaponType === 'default' ? '专' : (player.weaponType === 'spread' ? '驻专' : '专');
        ctx.fillText(`砖拽: ${weaponName} (专 ${player.powerUpLevel})`, 10, 90);
        ctx.textAlign = 'right';
        ctx.fillText(`: ${'わ'.repeat(lives)}`, canvas.width - 10, 30);
        
        //   住
        if(isBossLevel && boss) {
            ctx.textAlign = 'center';
            ctx.fillText(' 住 ', canvas.width/2, 30);
            const barWidth = canvas.width * 0.8;
            const barX = canvas.width * 0.1;
            ctx.fillStyle = 'red';
            ctx.fillRect(barX, 50, barWidth, 20);
            ctx.fillStyle = 'purple';
            ctx.fillRect(barX, 50, barWidth * (boss.health / boss.maxHealth), 20);
        }
        ctx.textAlign = 'center';
    }

    function resetGame() {
        score = 0; level = 1; lives = 3; gameFrame = 0;
        player.x = canvas.width / 2 - player.width / 2;
        player.y = canvas.height - player.height - 20;
        player.weaponType = 'default'; player.powerUpLevel = 1;
        enemies = []; playerProjectiles = []; powerUps = []; explosions = []; enemyProjectiles = [];
        isBossLevel = false; boss = null;
    }

    function startGame() {
        resetGame();
        gameState = 'playing';
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        animate();
    }
    
    function endGame() {
        gameState = 'gameOver';
        document.getElementById('finalScore').innerText = score;
        document.getElementById('finalLevel').innerText = level;
        document.getElementById('gameOverScreen').style.display = 'flex';
    }

    // ==================
    // 转 砖拽 专砖转
    // ==================
    function animate() {
        if (gameState !== 'playing') return;
        
        ctx.save();
        applyScreenShake();
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        handleStars();
        
        player.update(input);
        player.draw();
        
        spawnWave();
        
        handleGameObjects(enemies);
        handleGameObjects(playerProjectiles);
        handleGameObjects(powerUps);
        handleGameObjects(explosions);
        handleGameObjects(enemyProjectiles);
        
        detectCollisions();
        
        drawUI();
        
        ctx.restore();
        
        gameFrame++;
        requestAnimationFrame(animate);
    }
    
    // ==================
    // 驻 专注
    // ==================
    document.getElementById('startButton').addEventListener('click', () => {
        // 转转 住 专砖转 专拽爪 专砖转
        audioManager.init();
        startGame();
    });
    document.getElementById('restartButton').addEventListener('click', startGame);

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.y = canvas.height - player.height - 20;
        stars = [];
        initStars();
    });
    
    initStars();

    </script>
</body>
</html>
