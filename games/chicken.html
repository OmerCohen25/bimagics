<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>转  V3</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background-color: #0c0c1c; display: block; touch-action: none; }
        .screen { position: absolute; text-align: center; background-color: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; max-width: 90%; }
        h1 { font-size: 2.2em; margin-bottom: 0.5em; }
        p { font-size: 1.1em; line-height: 1.5; }
        button { font-size: 1.5em; padding: 10px 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 1em; }
    </style>
</head>
<body>
    <div id="startScreen" class="screen">
        <h1>转  V3</h1>
        <p>注 砖拽 砖,   拽专转 住 转专!</p>
        <button id="startButton">转 砖拽</button>
    </div>
    <div id="gameOverScreen" class="screen" style="display:none;">
        <h1>砖拽 专</h1>
        <p>拽 住驻: <span id="finalScore">0</span></p>
        <p>砖: <span id="finalLevel">0</span></p>
        <button id="restartButton">砖拽 砖</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
    // ==================
    // 专转 转
    // ==================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let gameState = 'start', score = 0, level = 1, lives = 3, gameFrame = 0;
    let isBossLevel = false, boss = null, isMuted = false;
    let screenShake = { intensity: 0, duration: 0 };
    let onScreenMessage = { text: '', timer: 0 };

    // 注专 住 拽
    let playerProjectiles = [], enemies = [], powerUps = [], explosions = [], stars = [], enemyProjectiles = [], particles = [];
    
    // 驻转专 住
    const muteButton = { x: 10, y: canvas.height - 40, width: 30, height: 30 };
    
    // ==================
    //  住
    // ==================
    const audioManager = {
        sounds: {},
        init() {
            this.sounds.shoot = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU9vT19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.explosion = new Audio("data:audio/wav;base64,UklGRkFvT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU5vT19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.powerup = new Audio("data:audio/wav;base64,UklGRlphV19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUxhV19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.playerHit = new Audio("data:audio/wav;base64,UklGRkFvT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU5vT19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t");
            this.sounds.laser = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABgAZGF0YQAAAAA=");
            this.sounds.missile = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABgAZGF0YQAcAAA=");
            Object.values(this.sounds).forEach(sound => { sound.volume = 0.5; });
            this.sounds.shoot.volume = 0.2; this.sounds.laser.loop = true; this.sounds.laser.volume = 0.3;
        },
        play(name) { if (!isMuted && this.sounds[name]) { this.sounds[name].currentTime = 0; this.sounds[name].play().catch(e => {}); } },
        stop(name) { if (this.sounds[name]) { this.sounds[name].pause(); this.sounds[name].currentTime = 0; } }
    };
    audioManager.init();

    // ==================
    // 拽住
    // ==================

    class Player {
        constructor() {
            this.width = 50; this.height = 50;
            this.x = canvas.width / 2 - this.width / 2; this.y = canvas.height - this.height - 20;
            this.weaponType = 'default'; this.powerUpLevel = 1; this.shootCooldown = 0;
            this.isInvincible = false; this.invincibilityTimer = 0; this.isFiringLaser = false;
        }

        update(input) {
            if (input.x) this.x = input.x - this.width / 2;
            if (this.x < 0) this.x = 0; if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;

            if (this.shootCooldown > 0) this.shootCooldown--;
            this.shoot();

            if(this.isInvincible) { this.invincibilityTimer--; if(this.invincibilityTimer <= 0) this.isInvincible = false; }
            
            if (this.weaponType === 'laser') { if (!this.isFiringLaser) { audioManager.play('laser'); this.isFiringLaser = true; } } 
            else { if (this.isFiringLaser) { audioManager.stop('laser'); this.isFiringLaser = false; } }
        }

        draw() {
            if (this.isInvincible && gameFrame % 10 < 5) return;
            ctx.font = '40px Arial'; ctx.fillText('', this.x, this.y + this.height - 10);
            if (this.weaponType === 'laser') this.drawLaser();
        }

        drawLaser() {
            const laserWidth = 5 + this.powerUpLevel * 2;
            ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
            ctx.fillRect(this.x + this.width/2 - laserWidth, 0, laserWidth * 2, this.y);
            ctx.fillStyle = `rgba(100, 200, 255, 0.8)`;
            ctx.fillRect(this.x + this.width/2 - laserWidth/2, 0, laserWidth, this.y);
        }

        shoot() {
            if (this.shootCooldown > 0 || this.weaponType === 'laser') return;
            switch (this.weaponType) {
                case 'homing':
                    playerProjectiles.push(new Projectile(this.x + this.width / 2, this.y, 0, 'homing'));
                    audioManager.play('missile'); this.shootCooldown = 40 - this.powerUpLevel * 3; break;
                case 'spread':
                    for(let i = 0; i < this.powerUpLevel + 2; i++) {
                         playerProjectiles.push(new Projectile(this.x + this.width / 2 - 5, this.y, i - (this.powerUpLevel+1)/2, 'default'));
                    }
                    audioManager.play('shoot'); this.shootCooldown = 20 - this.powerUpLevel; break;
                case 'default':
                default:
                    const bullets = Math.min(3, this.powerUpLevel);
                    for(let i=0; i<bullets; i++) {
                       playerProjectiles.push(new Projectile(this.x + this.width/2 - 15 + (i*15), this.y-i*5, 0, 'default'));
                    }
                    audioManager.play('shoot'); this.shootCooldown = 15 - this.powerUpLevel; break;
            }
        }
        
        takeHit() {
            if (this.isInvincible) return;
            lives--;
            audioManager.play('playerHit'); triggerScreenShake(10, 30);
            this.isInvincible = true; this.invincibilityTimer = 120;
            if (this.weaponType === 'laser') { audioManager.stop('laser'); this.isFiringLaser = false; }
            this.powerUpLevel = 1; this.weaponType = 'default';
            if (lives <= 0) endGame();
        }
    }

    class Projectile {
        constructor(x, y, speedX, type) {
            this.x = x; this.y = y; this.type = type;
            this.width = 10; this.height = 15;
            this.speedY = 12; this.speedX = speedX * 2.5; this.damage = 1;
            this.emoji = '';
            if(type === 'homing'){
                this.emoji = ''; this.target = this.findClosestEnemy();
                this.speedY = 6; this.turnSpeed = 0.1;
            }
        }
        findClosestEnemy(){ return enemies.sort((a,b) => Math.hypot(this.x-a.x, this.y-a.y) - Math.hypot(this.x-b.x, this.y-b.y))[0]; }
        update() {
            if(this.type === 'homing' && this.target && enemies.includes(this.target)){
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speedY; this.y += Math.sin(angle) * this.speedY;
            } else { this.y -= this.speedY; this.x += this.speedX; }
        }
        draw() { ctx.font = '20px Arial'; ctx.fillText(this.emoji, this.x, this.y); }
    }
    
    class EnemyProjectile { /* ...  砖 ... */ }
    class Star { /* ...  砖 ... */ }

    const enemyTypes = {
        normal: { health: 1, size: 40, emoji: '', points: 10, shootCd: 150 },
        tough: { health: 5, size: 50, emoji: '', points: 50, shootCd: 120 },
        bomber: { health: 2, size: 45, emoji: '', points: 30, shootCd: 80 },
        swerving: { health: 2, size: 40, emoji: '', points: 40, shootCd: 100, pattern: 'sine' },
        tank: { health: 20, size: 60, emoji: '', points: 100, shootCd: 200 },
        spawner: { health: 10, size: 55, emoji: '', points: 80, shootCd: 180, pattern: 'spawn' },
        boss: { health: 100, size: 120, emoji: '', points: 1000, shootCd: 40 }
    };

    class Enemy {
        constructor(x, y, type) {
            const proto = enemyTypes[type];
            this.x = x; this.y = y; this.type = type; this.pattern = proto.pattern;
            this.width = proto.size; this.height = proto.size;
            this.maxHealth = proto.health + Math.floor(level/2);
            this.health = this.maxHealth;
            this.emoji = proto.emoji; this.points = proto.points;
            this.speedY = (this.type === 'tank' ? 0.5 : 1) + Math.random() * 1.5 + level * 0.1;
            this.shootTimer = Math.random() * proto.shootCd; this.shootCooldown = proto.shootCd;
            this.spawnTimer = 180;
        }
        update() {
            this.y += this.speedY;
            if (this.pattern === 'sine') this.x += Math.sin(this.y * 0.05) * 3;
            if (this.pattern === 'spawn') {
                this.spawnTimer--;
                if(this.spawnTimer <= 0){
                    enemies.push(new Enemy(this.x, this.y, 'normal'));
                    this.spawnTimer = 240 - level*2;
                }
            }

            this.shootTimer--;
            if (this.shootTimer <= 0) {
                if (this.pattern !== 'spawn') this.shoot();
                this.shootTimer = this.shootCooldown - level * 2;
            }
        }
        draw() {
            ctx.font = `${this.width}px Arial`; ctx.fillText(this.emoji, this.x, this.y);
            if(this.maxHealth > 1) {
                ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 15, this.width, 10);
                ctx.fillStyle = 'green'; ctx.fillRect(this.x, this.y - 15, this.width * (this.health/this.maxHealth), 10);
            }
        }
        shoot() { /* ...  砖 砖注转 ... */ }
        takeDamage(amount) {
            this.health -= amount;
            if (this.health > 0) {
                for(let i=0; i<3; i++) particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, 'yellow'));
            }
            return this.health <= 0;
        }
    }
    
    const powerUpTypes = {
        weapon_spread: { emoji: 'S', color: '#33ff33'}, weapon_laser: { emoji: 'L', color: '#33ccff'},
        weapon_homing: { emoji: 'H', color: '#ff9933'}, health_up: { emoji: '+', color: '#ff3333'}
    };

    class PowerUp { /* ...  砖 ... */ }
    class Explosion {
        constructor(x, y, size) { this.x = x; this.y = y; this.size = size; this.timer = 0; this.maxTimer = 15; }
        update() { this.timer++; }
        draw() {
            ctx.globalAlpha = 1 - (this.timer / this.maxTimer);
            ctx.font = `${this.size * (1 + this.timer/this.maxTimer)}px Arial`;
            ctx.fillText('', this.x, this.y);
            ctx.globalAlpha = 1;
        }
    }
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.size = Math.random() * 5 + 2;
            this.speedX = (Math.random() - 0.5) * 3; this.speedY = (Math.random() - 0.5) * 3;
            this.color = color; this.lifespan = 20;
        }
        update() { this.x += this.speedX; this.y += this.speedY; this.lifespan--; }
        draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
    }


    // ==================
    // 驻拽爪转  砖拽
    // ==================
    const player = new Player();

    function spawnWave() {
        if (isBossLevel) return;
        if (level % 5 === 0 && enemies.length === 0) {
            isBossLevel = true;
            boss = new Enemy(canvas.width/2 - 60, -150, 'boss');
            enemies.push(boss);
            showOnScreenMessage('拽专 住!', 120);
            return;
        }
        if (gameFrame % (Math.max(15, 80 - level * 3)) === 0) {
             let x = Math.random() * (canvas.width - 60); let y = -50;
             let rand = Math.random();
             let enemyType = 'normal';
             if (level > 2 && rand < 0.3) enemyType = 'tough';
             else if (level > 4 && rand < 0.5) enemyType = 'swerving';
             else if (level > 6 && rand < 0.6) enemyType = 'tank';
             else if (level > 8 && rand < 0.7) enemyType = 'spawner';
             if (level > 3 && rand > 0.9) enemyType = 'bomber';
             enemies.push(new Enemy(x, y, enemyType));
        }
    }

    function handleGameObjects(arr) {
        for (let i = arr.length - 1; i >= 0; i--) {
            arr[i].update();
            arr[i].draw();
            if (arr[i].y > canvas.height + 50 || arr[i].y < -50 || (arr[i].lifespan && arr[i].lifespan <= 0) || (arr[i].timer >= arr[i].maxTimer)) {
                arr.splice(i, 1);
            }
        }
    }

    function detectCollisions() {
        // 转砖转 拽注 砖拽 
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (!enemy) continue;

            // 拽转 驻注转 专
            if (player.weaponType === 'laser') {
                const laserWidth = 5 + player.powerUpLevel * 2;
                const laserX = player.x + player.width/2 - laserWidth/2;
                if(enemy.x < laserX + laserWidth && enemy.x + enemy.width > laserX) {
                    if(enemy.takeDamage(0.2 + player.powerUpLevel * 0.1)){
                        killEnemy(enemy, i); continue;
                    }
                }
            }

            // 拽转 驻注转 拽注 专
            for (let j = playerProjectiles.length - 1; j >= 0; j--) {
                const projectile = playerProjectiles[j];
                if (!projectile) continue;
                if (projectile.x < enemy.x + enemy.width && projectile.x + projectile.width > enemy.x &&
                    projectile.y < enemy.y + enemy.height && projectile.y + projectile.height > enemy.y) 
                {
                    playerProjectiles.splice(j, 1);
                    if(enemy.takeDamage(projectile.damage)) {
                        killEnemy(enemy, i); break; //  转, 注专  
                    }
                }
            }
        }
        
        // 转砖转 /爪 砖拽
        /* ...  砖 ... */

        // 转砖转 砖拽 注 砖专
        /* ...  砖, 注 住驻转 case -homing ... */
    }

    function killEnemy(enemy, index) {
        explosions.push(new Explosion(enemy.x, enemy.y, enemy.width));
        audioManager.play('explosion'); triggerScreenShake(enemy.width * 0.1, 15);
        score += enemy.points;

        if (Math.random() < 0.2) { /*... 拽转 驻转 砖专 ...*/ }

        if (isBossLevel && enemy.type === 'boss') {
            isBossLevel = false; boss = null;
            level++; showOnScreenMessage(`砖 ${level}`, 90); score += 5000;
        }
        
        enemies.splice(index, 1);

        if (!isBossLevel && score > level * 750) {
            level++; showOnScreenMessage(`砖 ${level}`, 90);
        }
    }
    
    function drawUI() {
        ctx.fillStyle = 'white'; ctx.font = '20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`拽: ${score}`, 10, 30);
        ctx.fillText(`砖: ${level}`, 10, 60);
        let weaponName;
        switch(player.weaponType){
            case 'default': weaponName = '专'; break; case 'spread': weaponName = '驻专'; break;
            case 'laser': weaponName = '专'; break; case 'homing': weaponName = '转转'; break;
        }
        ctx.fillText(`砖拽: ${weaponName} (${player.powerUpLevel})`, 10, 90);
        ctx.textAlign = 'right';
        ctx.fillText(`: ${'わ'.repeat(lives)}`, canvas.width - 10, 30);
        
        // 驻转专 住
        ctx.font = '30px Arial';
        ctx.fillText(isMuted ? '' : '', muteButton.x + muteButton.width / 2, muteButton.y + muteButton.height / 2 + 10);

        if(isBossLevel && boss) { /* ... UI 砖 住 ... */ }
        
        if (onScreenMessage.timer > 0) {
            ctx.textAlign = 'center';
            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = `rgba(255, 255, 100, ${onScreenMessage.timer / 60})`;
            ctx.fillText(onScreenMessage.text, canvas.width/2, canvas.height/2);
            onScreenMessage.timer--;
        }
        ctx.textAlign = 'center';
    }
    
    function showOnScreenMessage(text, duration) { onScreenMessage.text = text; onScreenMessage.timer = duration; }

    // ==================
    // 转 砖拽 专砖转
    // ==================
    function animate() {
        if (gameState !== 'playing') return;
        
        ctx.save();
        // applyScreenShake();
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        handleGameObjects(stars);
        handleGameObjects(particles);
        
        player.update(input);
        player.draw();
        
        spawnWave();
        
        handleGameObjects(enemies);
        handleGameObjects(playerProjectiles);
        handleGameObjects(powerUps);
        handleGameObjects(enemyProjectiles);
        handleGameObjects(explosions);
        
        detectCollisions();
        
        drawUI();
        
        ctx.restore();
        
        gameFrame++;
        requestAnimationFrame(animate);
    }
    
    // ==================
    // 驻 专注
    // ==================
    function handleCanvasClick(e) {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        if (clickX >= muteButton.x && clickX <= muteButton.x + muteButton.width &&
            clickY >= muteButton.y && clickY <= muteButton.y + muteButton.height) {
            isMuted = !isMuted;
            if (isMuted) audioManager.stop('laser'); // 注爪专 专  砖转拽
        }
    }
    canvas.addEventListener('click', handleCanvasClick);

    // 转 驻注转 砖拽
    function init() {
        // 住 注专 专砖, 砖 
        for(let i=0; i<100; i++) stars.push(new Star());
    }

    function startGame() {
        // resetGame();
        gameState = 'playing';
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'none';
        animate();
    }

    document.getElementById('startButton').addEventListener('click', () => {
        audioManager.init();
        startGame();
    });

    init(); // 拽专 转 专砖

    </script>
</body>
</html>

