<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>מלחמת החלל V5.0 - הגרסה הסופית</title>
    <style>
        body { margin: 0; background-color: #000; color: #fff; font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { background-color: #0c0c1c; display: block; touch-action: none; }
        .screen {
            position: absolute;
            text-align: center;
            background-color: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            max-width: 90%;
            z-index: 10; /* חשוב כדי להבטיח שהמסך מעל הקנבס */
        }
        h1 { font-size: 2.2em; margin-bottom: 0.5em; }
        p { font-size: 1.1em; line-height: 1.5; }
        button { font-size: 1.2em; padding: 12px 24px; cursor: pointer; background-color: #4CAF50; color: white; border: 2px solid #80c080; border-radius: 8px; margin-top: 1em; }
        button:hover { background-color: #45a049; }
        #shareButton { background-color: #007bff; border-color: #50a0ff;}
        #shareButton:hover { background-color: #0069d9; }
        .error-container { color: white; background-color: #330000; border: 2px solid red; padding: 20px; font-family: monospace; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="startScreen" class="screen">
        <h1>מלחמת החלל V5.0</h1>
        <p>הגרסה הסופית עם כל השדרוגים!</p>
        <button id="startButton">התחל משחק</button>
    </div>
    <div id="gameOverScreen" class="screen" style="display:none;">
        <h1>המשחק נגמר</h1>
        <p>ניקוד סופי: <span id="finalScore">0</span></p>
        <p>שלב: <span id="finalLevel">0</span></p>
        <button id="restartButton">שחק שוב</button>
        <button id="shareButton">שתף תוצאה 📲</button>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// V5.0 - שדרוג נשק גלובלי, תיקון מסך סיום, הוספת כפתור שיתוף.
try {
    
    // ==================
    // הגדרות כלליות
    // ==================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let gameState = 'start', score = 0, level = 1, lives = 3, gameFrame = 0;
    let isBossLevel = false, boss = null, isMuted = false;
    let screenShake = { intensity: 0, duration: 0 };
    let onScreenMessage = { text: '', timer: 0 };

    let playerProjectiles = [], enemies = [], powerUps = [], explosions = [], stars = [], enemyProjectiles = [], particles = [];
    const muteButton = { x: 10, y: window.innerHeight - 40, width: 30, height: 30 };
    const MAX_WEAPON_LEVEL = 8;
    const GAME_URL = 'https://bimagics.com/games/chicken.html';

    // ==================
    // מנהל סאונד
    // ==================
    const audioManager = { sounds: {}, init() { this.sounds.shoot = new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU9vT19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t"); this.sounds.explosion = new Audio("data:audio/wav;base64,UklGRkAIAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA="); this.sounds.powerup = new Audio("data:audio/wav;base64,UklGRlphV19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YUxhV19JTU5GT0ZGSQAAABwAAABBAAAAQ09ERVJTPTEuMAAATkxpc3RpbmZvbwAAAEBhcnRpc3QAAABqc2Z4cgAAAENPQllSSUdIVAAAADg4bW1tbW1t"); this.sounds.playerHit = new Audio("data:audio/wav;base64,UklGRkIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQBIAAA="); this.sounds.laser = new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABgAZGF0YQAAAAA="); this.sounds.missile = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABgAZGF0YQAcAAA="); Object.values(this.sounds).forEach(sound => { sound.volume = 0.4; }); this.sounds.shoot.volume = 0.2; this.sounds.laser.loop = true; this.sounds.laser.volume = 0.3; }, play(name) { if (!isMuted && this.sounds[name]) { this.sounds[name].currentTime = 0; this.sounds[name].play().catch(e => {}); } }, stop(name) { if (this.sounds[name]) { this.sounds[name].pause(); this.sounds[name].currentTime = 0; } } };
    audioManager.init();

    // ==================
    // קלאסים
    // ==================
    class Player {
        constructor() {
            this.width = 50; this.height = 50;
            this.x = canvas.width / 2 - this.width / 2; this.y = canvas.height - this.height - 20;
            this.weaponType = 'default';
            this.powerUpLevel = 1; // רמת כוח גלובלית
            this.shootCooldown = 0; this.isInvincible = false; this.invincibilityTimer = 0; this.isFiringLaser = false;
        }
        update(input) {
            if (input.x) this.x = input.x - this.width / 2;
            if (input.y) this.y = input.y - this.height / 2;
            if (this.x < 0) this.x = 0; if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
            if (this.y < 0) this.y = 0; if (this.y > canvas.height - this.height) this.y = canvas.height - this.height;
            if (this.shootCooldown > 0) this.shootCooldown--;
            this.shoot();
            if (this.isInvincible) { this.invincibilityTimer--; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
            const isLaserActive = this.weaponType === 'laser' && !this.isFiringLaser && gameState === 'playing';
            if (isLaserActive) { if (!isMuted) audioManager.play('laser'); this.isFiringLaser = true; } 
            else if (this.isFiringLaser) { audioManager.stop('laser'); this.isFiringLaser = false; }
        }
        draw() { if (this.isInvincible && gameFrame % 10 < 5) return; ctx.font = '40px Arial'; ctx.fillText('🚀', this.x, this.y + this.height - 10); if (this.weaponType === 'laser') this.drawLaser(); }
        drawLaser() { const laserWidth = 5 + this.powerUpLevel * 2; ctx.fillStyle = `rgba(255, 255, 255, 0.2)`; ctx.fillRect(this.x + this.width/2 - laserWidth, 0, laserWidth * 2, this.y); ctx.fillStyle = `rgba(100, 200, 255, 0.8)`; ctx.fillRect(this.x + this.width/2 - laserWidth/2, 0, laserWidth, this.y); }
        shoot() {
            if (this.shootCooldown > 0 || this.weaponType === 'laser') return;
            const level = this.powerUpLevel;
            switch (this.weaponType) {
                case 'piercing': playerProjectiles.push(new Projectile(this.x + this.width/2, this.y, 0, 'piercing')); audioManager.play('missile'); this.shootCooldown = 35 - level * 2; break;
                case 'rear': playerProjectiles.push(new Projectile(this.x + this.width/2 - 5, this.y, 0, 'default')); for(let i=0; i < Math.floor(level/2); i++){ playerProjectiles.push(new Projectile(this.x + this.width/2 - 5, this.y, 0, 'rear')); } audioManager.play('shoot'); this.shootCooldown = 15 - level; break;
                case 'homing': playerProjectiles.push(new Projectile(this.x + this.width / 2, this.y, 0, 'homing')); audioManager.play('missile'); this.shootCooldown = 40 - level * 3; break;
                case 'spread': for(let i = 0; i < level + 2; i++) { playerProjectiles.push(new Projectile(this.x + this.width / 2 - 5, this.y, i - (level+1)/2, 'default')); } audioManager.play('shoot'); this.shootCooldown = 20 - level; break;
                default: const bullets = Math.min(3, level); for(let i=0; i<bullets; i++) { playerProjectiles.push(new Projectile(this.x + this.width/2 - 15 + (i*15), this.y-i*5, 0, 'default')); } audioManager.play('shoot'); this.shootCooldown = 15 - level; break;
            }
        }
        takeHit() { if (this.isInvincible) return; lives--; audioManager.play('playerHit'); triggerScreenShake(10, 30); this.isInvincible = true; this.invincibilityTimer = 120; if (this.isFiringLaser) { audioManager.stop('laser'); this.isFiringLaser = false; } if (lives <= 0) { endGame(); } }
    }

    function getProjectileStyle(type, level) { if (level < 4) return { emoji: '🔥', size: 20 }; if (level < 7) return { emoji: '💧', size: 25 }; return { emoji: '✨', size: 30 }; }

    class Projectile {
        constructor(x, y, speedX, type) {
            this.x = x; this.y = y; this.type = type;
            const level = player.powerUpLevel; const style = getProjectileStyle(type, level);
            this.emoji = style.emoji; this.size = style.size; this.width = this.size; this.height = this.size;
            this.speedY = 12; this.speedX = speedX * 2.5; this.damage = 1;
            switch(type) {
                case 'homing': this.emoji = '🎯'; this.target = this.findClosestEnemy(); this.speedY = 6; break;
                case 'piercing': this.emoji = '⚡'; this.penetration = level; this.speedY = 15; break;
                case 'rear': this.speedY = -10; break;
            }
        }
        findClosestEnemy(){ return enemies.length > 0 ? enemies.sort((a,b) => Math.hypot(this.x-a.x, this.y-a.y) - Math.hypot(this.x-b.x, this.y-b.y))[0] : null; }
        update() { if(this.type === 'homing' && this.target && enemies.includes(this.target)){ const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); this.x += Math.cos(angle) * this.speedY; this.y += Math.sin(angle) * this.speedY; } else { this.y -= this.speedY; this.x += this.speedX; } }
        draw() { ctx.font = `${this.size}px Arial`; ctx.fillText(this.emoji, this.x, this.y); }
        onHit() {
            if (this.type === 'piercing') { this.penetration--; return this.penetration < 0; }
            if (this.type === 'homing' && player.powerUpLevel >= 5) { explosions.push(new Explosion(this.x, this.y, 60, true)); }
            return true;
        }
    }
    class EnemyProjectile { constructor(x, y, speedX = 0, speedY = 4, type = 'egg') { this.x = x; this.y = y; this.speedX = speedX; this.speedY = speedY + level * 0.1; this.type = type; this.emoji = type === 'egg' ? '🥚' : '💀'; this.width = 25; this.height = 25; } update() { if (this.type === 'homing') { if(player.health > 0){ const angle = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angle) * (this.speedY / 2); this.y += Math.sin(angle) * (this.speedY / 2); } else { this.y += this.speedY; } } else { this.x += this.speedX; this.y += this.speedY; } } draw() { ctx.font = '25px Arial'; ctx.fillText(this.emoji, this.x, this.y); } }
    class Star { constructor() { this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height; this.size = Math.random() * 2 + 1; this.speed = Math.random() * 1 + 0.5; } update() { this.y += this.speed; if (this.y > canvas.height) { this.y = 0; this.x = Math.random() * canvas.width; } } draw() { ctx.fillStyle = 'white'; ctx.fillRect(this.x, this.y, this.size, this.size); } }
    class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.size = Math.random() * 5 + 2; this.speedX = (Math.random() - 0.5) * 3; this.speedY = (Math.random() - 0.5) * 3; this.color = color; this.lifespan = 20; } update() { this.x += this.speedX; this.y += this.speedY; this.lifespan--; } draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); } }
    const enemyTypes = { normal: { health: 1, size: 40, emoji: '🐔', points: 10 }, tough: { health: 5, size: 50, emoji: '🐓', points: 50 }, bomber: { health: 2, size: 45, emoji: '🛸', points: 30 }, swerving: { health: 2, size: 40, emoji: '🐧', points: 40, pattern: 'sine' }, tank: { health: 20, size: 60, emoji: '🦉', points: 100 }, spawner: { health: 10, size: 55, emoji: '👾', points: 80, pattern: 'spawn' }, boss: { health: 100, size: 120, emoji: '👹', points: 1000 } };
    class Enemy { constructor(x, y, type) { const proto = enemyTypes[type]; this.x = x; this.y = y; this.type = type; this.pattern = proto.pattern; this.width = proto.size; this.height = proto.size; this.maxHealth = proto.health + Math.floor(level * 1.5); this.health = this.maxHealth; this.emoji = proto.emoji; this.points = proto.points; this.speedY = (this.type === 'tank' ? 0.5 : 1) + Math.random() * 1.5 + level * 0.1; if (this.type === 'boss') { this.speedX = 2 + level * 0.2; this.directionX = 1; this.attackPhase = 0; this.attackTimer = 120; } else { this.shootTimer = Math.random() * 150; } } update() { if (this.type === 'boss') { if (this.y < 50) { this.y += 1; } else { this.x += this.speedX * this.directionX; if (this.x <= 0 || this.x >= canvas.width - this.width) { this.directionX *= -1; } } this.attackTimer--; if (this.attackTimer <= 0) { this.performAttack(); this.attackTimer = 150 - level * 5; } } else { this.y += this.speedY; if (this.pattern === 'sine') this.x += Math.sin(this.y * 0.05) * 3; if (this.pattern === 'spawn') { if (gameFrame % 180 === 0 && enemies.length < 50) { enemies.push(new Enemy(this.x, this.y, 'normal')); } } if (gameFrame % 100 === 0 && this.pattern !== 'spawn' && this.y > 0) { this.shoot(); } } } draw() { ctx.font = `${this.width}px Arial`; ctx.fillText(this.emoji, this.x, this.y); if (this.maxHealth > 1) { ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 15, this.width, 10); ctx.fillStyle = 'green'; ctx.fillRect(this.x, this.y - 15, this.width * (this.health / this.maxHealth), 10); } } shoot() { enemyProjectiles.push(new EnemyProjectile(this.x + this.width / 2, this.y + this.height)); } performAttack() { this.attackPhase = (this.attackPhase + 1) % 3; const centerX = this.x + this.width / 2; const centerY = this.y + this.height; switch(this.attackPhase) { case 0: for (let i = 0; i < 3; i++) { setTimeout(() => { if(this.health > 0) enemyProjectiles.push(new EnemyProjectile(centerX, centerY)); }, i * 150); } break; case 1: for (let i = -2; i <= 2; i++) { enemyProjectiles.push(new EnemyProjectile(centerX, centerY, i * 2, 4, 'egg')); } break; case 2: enemyProjectiles.push(new EnemyProjectile(centerX, centerY, 0, 2, 'homing')); break; } } takeDamage(amount) { this.health -= amount; if (this.health > 0) { for (let i = 0; i < 3; i++) particles.push(new Particle(this.x + this.width / 2, this.y + this.height / 2, 'yellow')); } return this.health <= 0; } }
    const powerUpTypes = { weapon_spread: { emoji: 'S', color: '#33ff33'}, weapon_laser: { emoji: 'L', color: '#33ccff'}, weapon_homing: { emoji: 'H', color: '#ff9933'}, weapon_piercing: { emoji: 'P', color: '#ff4dff' }, weapon_rear: { emoji: 'R', color: '#ffff00' }, health_up: { emoji: '+', color: '#ff3333' } };
    class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.width = 30; this.height = 30; this.speedY = 2; } update() { this.y += this.speedY; } draw() { const proto = powerUpTypes[this.type]; ctx.font = 'bold 30px Arial'; ctx.fillStyle = proto.color; ctx.fillText(proto.emoji, this.x, this.y); } }
    class Explosion { constructor(x, y, size, isAoE = false) { this.x = x; this.y = y; this.size = size; this.isAoE = isAoE; this.radius = size / 2; this.timer = 0; this.maxTimer = 15; } update() { this.timer++; if (this.isAoE && this.timer === 1) { this.dealAoEDamage(); } } dealAoEDamage() { for (const enemy of enemies) { if (!enemy) continue; const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y); if (dist < this.radius + enemy.width/2) { if (enemy.takeDamage(5)) { const index = enemies.indexOf(enemy); if (index > -1) killEnemy(enemy, index); } } } } draw() { ctx.globalAlpha = 1 - (this.timer / this.maxTimer); ctx.font = `${this.size * (1 + this.timer/this.maxTimer)}px Arial`; ctx.fillText(this.isAoE ? '💣' : '💥', this.x, this.y); ctx.globalAlpha = 1; } }
    
    const player = new Player();
    const input = { x: canvas.width / 2, y: canvas.height - 80 };
    
    window.addEventListener('mousemove', e => { if (gameState === 'playing') { input.x = e.clientX; input.y = e.clientY; } });
    window.addEventListener('touchmove', e => { e.preventDefault(); if (gameState === 'playing' && e.touches.length > 0) { input.x = e.touches[0].clientX; input.y = e.touches[0].clientY; } }, { passive: false });

    function spawnWave() { if (isBossLevel) return; if (level % 5 === 0 && enemies.length === 0) { isBossLevel = true; boss = new Enemy(canvas.width/2 - 60, -150, 'boss'); enemies.push(boss); showOnScreenMessage('קרב בוס!', 120); return; } if (gameFrame % (Math.max(15, 80 - level * 3)) === 0) { let x = Math.random() * (canvas.width - 60); let y = -50; let rand = Math.random(); let enemyType = 'normal'; if (level > 2 && rand < 0.3) enemyType = 'tough'; else if (level > 4 && rand < 0.5) enemyType = 'swerving'; else if (level > 6 && rand < 0.6) enemyType = 'tank'; else if (level > 8 && rand < 0.7) enemyType = 'spawner'; if (level > 3 && rand > 0.9) enemyType = 'bomber'; enemies.push(new Enemy(x, y, enemyType)); } }
    function handleGameObjects(arr) { for (let i = arr.length - 1; i >= 0; i--) { const obj = arr[i]; if(obj) { obj.update(); obj.draw(); if (obj.y > canvas.height + 50 || obj.y < -150 || (obj.lifespan && obj.lifespan <= 0) || (obj.maxTimer && obj.timer >= obj.maxTimer)) { arr.splice(i, 1); } } } }
    function detectCollisions() {
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i]; if (!enemy) continue;
            if (player.weaponType === 'laser') { const laserWidth = 5 + player.powerUpLevel * 2; const laserX = player.x + player.width/2 - laserWidth/2; if(enemy.x < laserX + laserWidth && enemy.x + enemy.width > laserX && enemy.y > 0) { if(enemy.takeDamage(0.2 + player.powerUpLevel * 0.1)){ killEnemy(enemy, i); continue; } } }
            for (let j = playerProjectiles.length - 1; j >= 0; j--) { const projectile = playerProjectiles[j]; if (!projectile || !enemy) continue; if (projectile.x < enemy.x + enemy.width && projectile.x + projectile.width > enemy.x && projectile.y < enemy.y + enemy.height && projectile.y + projectile.height > enemy.y) { if (projectile.onHit()) { playerProjectiles.splice(j, 1); } if(enemy.takeDamage(projectile.damage)) { killEnemy(enemy, i); break; } } }
        }
        const entitiesToTest = [...enemies, ...enemyProjectiles];
        for (let i = entitiesToTest.length - 1; i >= 0; i--) { const entity = entitiesToTest[i]; if (entity && player.x < entity.x + entity.width && player.x + player.width > entity.x && player.y < entity.y + entity.height && player.y + player.height > entity.y) { player.takeHit(); explosions.push(new Explosion(entity.x, entity.y, entity.width)); const enemyIndex = enemies.indexOf(entity); if (enemyIndex > -1) { enemies.splice(enemyIndex, 1); continue; } const projIndex = enemyProjectiles.indexOf(entity); if (projIndex > -1) { enemyProjectiles.splice(projIndex, 1); } } }
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];
            if (powerUp && player.x < powerUp.x + powerUp.width && player.x + player.width > powerUp.x && player.y < powerUp.y + powerUp.height && player.y + player.height > powerUp.y) {
                audioManager.play('powerup');
                if (powerUp.type === 'health_up') { if (lives < 5) lives++; } 
                else if (powerUp.type.startsWith('weapon_')) {
                    if (player.powerUpLevel < MAX_WEAPON_LEVEL) { player.powerUpLevel++; } else { score += 500; }
                    player.weaponType = powerUp.type.split('_')[1];
                }
                powerUps.splice(i, 1); score += 50;
            }
        }
    }
    function killEnemy(enemy, index) { if (!enemies[index] || enemies[index] !== enemy) return; explosions.push(new Explosion(enemy.x, enemy.y, enemy.width)); audioManager.play('explosion'); triggerScreenShake(enemy.width * 0.1, 15); score += enemy.points; if (Math.random() < 0.2) { const powerUpKeys = Object.keys(powerUpTypes); const randomType = powerUpKeys[Math.floor(Math.random() * powerUpKeys.length)]; powerUps.push(new PowerUp(enemy.x, enemy.y, randomType)); } if (isBossLevel && enemy.type === 'boss') { isBossLevel = false; boss = null; level++; showOnScreenMessage(`שלב ${level}`, 90); score += 5000; } enemies.splice(index, 1); if (!isBossLevel && score > level * 750) { level++; showOnScreenMessage(`שלב ${level}`, 90); } }
    function triggerScreenShake(intensity, duration) { screenShake.intensity = intensity; screenShake.duration = duration; }
    function applyScreenShake() { if (screenShake.duration > 0) { ctx.translate((Math.random() - 0.5) * screenShake.intensity, (Math.random() - 0.5) * screenShake.intensity); screenShake.duration--; } else { screenShake.intensity = 0; } }
    function drawUI() { ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.textAlign = 'right'; ctx.fillText(`ניקוד: ${score}`, canvas.width - 10, 30); ctx.fillText(`שלב: ${level}`, canvas.width - 10, 60); let weaponName; switch(player.weaponType){ case 'default': weaponName = 'רגיל'; break; case 'spread': weaponName = 'מפוזר'; break; case 'laser': weaponName = 'לייזר'; break; case 'homing': weaponName = 'מתביית'; break; case 'piercing': weaponName = 'חודר'; break; case 'rear': weaponName = 'אחורי'; break; } const levelText = player.powerUpLevel >= MAX_WEAPON_LEVEL ? 'MAX' : player.powerUpLevel; ctx.fillText(`נשק: ${weaponName} (רמה ${levelText})`, canvas.width - 10, 90); ctx.textAlign = 'left'; ctx.fillText(`חיים: ${'❤️'.repeat(lives)}`, 10, 30); ctx.font = '30px Arial'; ctx.fillText(isMuted ? '🔇' : '🔊', muteButton.x, muteButton.y + muteButton.height - 5); if(isBossLevel && boss && boss.health > 0) { ctx.textAlign = 'center'; ctx.fillText('🚨 בוס 🚨', canvas.width/2, 30); const barWidth = canvas.width * 0.8, barX = canvas.width * 0.1; ctx.fillStyle = 'red'; ctx.fillRect(barX, 50, barWidth, 20); ctx.fillStyle = 'purple'; ctx.fillRect(barX, 50, barWidth * (boss.health / boss.maxHealth), 20); } if (onScreenMessage.timer > 0) { ctx.textAlign = 'center'; ctx.font = 'bold 50px Arial'; ctx.fillStyle = `rgba(255, 255, 100, ${onScreenMessage.timer / 60})`; ctx.fillText(onScreenMessage.text, canvas.width/2, canvas.height/2); onScreenMessage.timer--; } }
    function showOnScreenMessage(text, duration) { onScreenMessage.text = text; onScreenMessage.timer = duration; }
    function resetGame() { score = 0; level = 1; lives = 3; gameFrame = 0; player.x = canvas.width / 2 - player.width / 2; player.y = canvas.height - player.height - 20; input.x = player.x; input.y = player.y; player.weaponType = 'default'; player.powerUpLevel = 1; player.isInvincible = false; enemies = []; playerProjectiles = []; powerUps = []; explosions = []; enemyProjectiles = []; particles = []; isBossLevel = false; boss = null; audioManager.stop('laser'); player.isFiringLaser = false; }
    function animate() { if (gameState !== 'playing') return; ctx.save(); applyScreenShake(); ctx.clearRect(0, 0, canvas.width, canvas.height); handleGameObjects(stars); handleGameObjects(particles); player.update(input); player.draw(); spawnWave(); handleGameObjects(enemies); handleGameObjects(playerProjectiles); handleGameObjects(powerUps); handleGameObjects(enemyProjectiles); handleGameObjects(explosions); detectCollisions(); drawUI(); ctx.restore(); gameFrame++; requestAnimationFrame(animate); }
    function handleCanvasClick(e) { const rect = canvas.getBoundingClientRect(); const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top; if (clickX >= muteButton.x && clickX <= muteButton.x + muteButton.width && clickY >= muteButton.y && clickY <= muteButton.y + muteButton.height) { isMuted = !isMuted; if (isMuted) { audioManager.stop('laser'); player.isFiringLaser = false; } } }
    function startGame() { resetGame(); gameState = 'playing'; document.getElementById('startScreen').style.display = 'none'; document.getElementById('gameOverScreen').style.display = 'none'; requestAnimationFrame(animate); }
    function endGame() { gameState = 'gameOver'; audioManager.stop('laser'); player.isFiringLaser = false; document.getElementById('finalScore').innerText = score; document.getElementById('finalLevel').innerText = level; document.getElementById('gameOverScreen').style.display = 'flex'; }
    function shareResult() {
        const shareText = `הגעתי לניקוד ${score} בשלב ${level} במלחמת החלל! נסו לנצח אותי:`;
        if (navigator.share) {
            navigator.share({ title: 'מלחמת החלל - התוצאה שלי!', text: shareText, url: GAME_URL }).catch(console.error);
        } else {
            navigator.clipboard.writeText(`${shareText} ${GAME_URL}`).then(() => {
                alert('התוצאה והקישור הועתקו! הדבק איפה שתרצה כדי לשתף.');
            }).catch(err => {
                console.error('Could not copy text: ', err);
                alert('לא ניתן היה להעתיק את התוצאה.');
            });
        }
    }
    document.getElementById('startButton').addEventListener('click', () => { audioManager.init(); startGame(); });
    document.getElementById('restartButton').addEventListener('click', startGame);
    document.getElementById('shareButton').addEventListener('click', shareResult);
    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; muteButton.y = canvas.height - 40; player.y = canvas.height - player.height - 20; });
    for(let i=0; i<100; i++) stars.push(new Star());

} catch (e) {
    document.body.innerHTML = `<div class="error-container"><h1>אוי, משהו השתבש!</h1><p>הקוד נתקל בשגיאה קריטית ולא יכול היה לעלות. זה כנראה באג במשחק.</p><pre>${e.stack}</pre></div>`;
}
</script>
</body>
</html>
