<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>RUN & BLAST: מסלול הקרב</title>
<style>
  html,body{margin:0;height:100%;background:#000;touch-action:none;overscroll-behavior:none}
  canvas{display:block;width:100vw;height:100vh;background:#000}
  #hud{
    position:fixed;top:0;left:0;right:0;pointer-events:none;
    display:flex;justify-content:space-between;align-items:center;
    padding:10px 12px;font-family:system-ui,Segoe UI,Arial;color:#e6edf3;mix-blend-mode:screen
  }
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 10px;font-weight:700}
  #story{position:fixed;top:52px;left:0;right:0;text-align:center;font-weight:800;letter-spacing:.5px;
    text-shadow:0 2px 12px #0008;color:#eef;opacity:0;transition:opacity .6s}
  #tips{position:fixed;bottom:10px;left:0;right:0;text-align:center;color:#c8d2e0;font-size:12px;opacity:.8;pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div class="pill" id="hp">❤️ 100</div>
  <div class="pill" id="score">⭐ 0</div>
  <div class="pill" id="stage">שלב 1 • 🤺 Basic</div>
</div>
<div id="story"></div>
<div id="tips">גררו את הגיבור ימינה ושמאלה כדי לעבור נתיב. הירי אוטומטי.</div>

<script>
(() => {
/* ===================== Canvas & Utils ===================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let DPR = Math.min(2.5, window.devicePixelRatio || 1);
let W=0,H=0;
function resize(){
  W = canvas.clientWidth = window.innerWidth;
  H = canvas.clientHeight = window.innerHeight;
  canvas.width = Math.floor(W * DPR);
  canvas.height= Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
new ResizeObserver(resize).observe(document.body);
resize();

function clamp(v,a,b){return Math.max(a, Math.min(b, v))}
function lerp(a,b,t){return a+(b-a)*t}
function rand(a,b){return a + Math.random()*(b-a)}
function pick(arr){return arr[(Math.random()*arr.length)|0]}

/* ===================== Audio (WebAudio, no files) ===================== */
let audioCtx, master, canAudio=false;
function initAudio(){
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain(); master.gain.value=0.12; master.connect(audioCtx.destination);
    canAudio = true;
  } catch(e){ canAudio=false; }
}
function beep({type='square',freq=440,dur=0.07,vol=0.3,decay=0.15}={}){
  if(!canAudio) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type=type; o.frequency.value=freq;
  g.gain.value=vol; g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+Math.max(dur,0.02)+decay);
  o.connect(g); g.connect(master); o.start(); o.stop(audioCtx.currentTime+dur+decay);
}
function noise({dur=0.15,vol=0.25,lp=1200}={}){
  if(!canAudio) return;
  const buff = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
  const data = buff.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*(1-i/data.length);
  const src=audioCtx.createBufferSource(); src.buffer=buff;
  const g=audioCtx.createGain(); g.gain.value=vol;
  const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
  src.connect(f); f.connect(g); g.connect(master);
  src.start(); src.stop(audioCtx.currentTime+dur);
}
function stageTone(stage){
  if(!canAudio) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type='sine'; o.frequency.value=140 + (stage%6)*30;
  g.gain.setValueAtTime(0.0001,audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime+0.15);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+1.0);
  o.connect(g); g.connect(master); o.start(); o.stop(audioCtx.currentTime+1.05);
}

/* ===================== Input ===================== */
// --- שינוי ---: הקלט שולט רק על הנתיב הרצוי, לא על מיקום מדויק
let inputX = W/2, touching=false;
canvas.addEventListener('pointerdown',e=>{if(!audioCtx) initAudio(); touching=true; setInput(e);});
canvas.addEventListener('pointermove',e=>{ if(touching) setInput(e); });
canvas.addEventListener('pointerup',()=>touching=false);
canvas.addEventListener('pointercancel',()=>touching=false);
function setInput(e){
  const r=canvas.getBoundingClientRect();
  inputX = clamp(e.clientX - r.left, 0, W);
}

/* ===================== Game State ===================== */
const hudHP = document.getElementById('hp');
const hudScore = document.getElementById('score');
const hudStage = document.getElementById('stage');
const storyEl = document.getElementById('story');

// --- שינוי ---: מבנה המצב של המשחק עודכן למכניקה החדשה
const STATE = {
  running:true, t:0, dt:0,
  score:0, stage:1, combo:0, comboTimer:0,
  lanes: [W*0.25, W*0.5, W*0.75], // --- חדש ---: מיקומי X של שלושת הנתיבים
  scrollSpeed: 280, // --- חדש ---: מהירות הגלילה של המסלול
  // player
  p:{ x:W/2, y:H*0.85, r:22, hp:100, maxHp:100, inv:0, weapon:0, magnet:140, fireDelay:130, fireTimer:0, dmg:6, targetLane:1 },
  bullets:[], enemies:[], coins:[], pickups:[], fx:[],
  spawnTimer:0, spawnDelay:550,
  weaponNames:['Basic','Twin','Spread','Laser','Rocket'],
  shake:0,
};

// --- שינוי ---: סיפור מותאם לאווירה החדשה
const STORY = [
  {name:'שביל הצללים', line:'האפלה קוראת, מפלצות קדומות חוסמות את דרכך.'},
  {name:'מדבר העצמות', line:'חולות רותחים, שרצים ארסיים אורבים בכל פינה.'},
  {name:'מצודת הגיהנום', line:'להבות ושדים שומרים על המבצר הארור.'},
  {name:'ריק הכוכבים', line:'יצורים קוסמיים מגיחים מהתוהו ובוהו.'},
];

const ENEMY_ICONS = ['👹', '👺', '🕷️', '🦂', '🐍', '🐲', '👻', '💀'];

function showStory(){
  const s = STORY[(STATE.stage-1)%STORY.length];
  storyEl.innerHTML = `⟡ ${s.name} ⟡<br/><span style="font-weight:600;opacity:.8">${s.line}</span>`;
  storyEl.style.opacity=1;
  setTimeout(()=>storyEl.style.opacity=0, 2200);
}

/* ===================== Entities ===================== */
// --- שינוי ---: יצירת אויבים מותאמת למערכת הנתיבים
function spawnEnemy(){
  const lane = pick([0,1,2]);
  const x = STATE.lanes[lane];
  const y = -40;
  
  const e = {
    lane, x, y, r:24,
    hp: 15 + STATE.stage * 3,
    icon: pick(ENEMY_ICONS),
    hit:0
  };
  STATE.enemies.push(e);
}

function makeCoin(x,y, lane){
  STATE.coins.push({x,y, lane, r:8, t:0});
}
function makePickup(x,y,kind, lane){
  STATE.pickups.push({x,y, lane, r:14, kind, t:0});
}

/* ===================== Weapons & Shooting (ללא שינוי מהותי) ===================== */
function playerShoot(){
  const p=STATE.p;
  if (p.weapon===0){ // basic
    STATE.bullets.push({x:p.x,y:p.y-24, vx:0, vy:-600, r:4, dmg:p.dmg});
    beep({type:'square',freq:680,vol:0.18,dur:0.05});
  } else if (p.weapon===1){ // twin
    STATE.bullets.push({x:p.x-10,y:p.y-24,vx:0,vy:-620,r:4,dmg:p.dmg-1});
    STATE.bullets.push({x:p.x+10,y:p.y-24,vx:0,vy:-620,r:4,dmg:p.dmg-1});
    beep({type:'square',freq:600,vol:0.18,dur:0.05});
  } else if (p.weapon===2){ // spread
    for(let a=-0.22;a<=0.22;a+=0.22){
      STATE.bullets.push({x:p.x,y:p.y-24,vx:Math.sin(a)*220,vy:-600,r:4,dmg:p.dmg-1});
    }
    beep({type:'sawtooth',freq:560,vol:0.16,dur:0.05});
  } else if (p.weapon===3){ // laser (beam)
    STATE.bullets.push({laser:true, t:0, x:p.x, y:0, vx:0, vy:0, r:3, dmg:Math.max(1, p.dmg-3)});
    beep({type:'triangle',freq:420,vol:0.12,dur:0.04});
  } else if (p.weapon===4){ // rocket
    STATE.bullets.push({x:p.x,y:p.y-26,vx:0,vy:-400,r:6,dmg:p.dmg+6,rocket:true, turn:0});
    noise({dur:0.08,vol:0.18,lp:1400});
  }
}

/* ===================== Background & Path Drawing ===================== */
// --- שינוי ---: פונקציה חדשה לגמרי שמציירת את המסלול והרקע
function drawPathAndBackground(t){
  const theme = (STATE.stage-1)%4;
  
  // 1. רקע כללי
  let bgGrad1, bgGrad2;
  if (theme===0) { bgGrad1='#021'; bgGrad2='#102844'; } // שביל הצללים
  else if (theme===1) { bgGrad1='#420'; bgGrad2='#853'; } // מדבר העצמות
  else if (theme===2) { bgGrad1='#400'; bgGrad2='#622'; } // מצודת הגיהנום
  else { bgGrad1='#000014'; bgGrad2='#001033'; } // ריק הכוכבים
  
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,bgGrad1); g.addColorStop(1,bgGrad2);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  
  // 2. ציור המסלול בפרספקטיבה
  const pathTopWidth = W * 0.4;
  const pathBottomWidth = W * 1.2;
  const pathColor = theme===0 ? '#345' : theme===1 ? '#a86' : theme===2 ? '#644' : '#335';
  
  ctx.fillStyle = pathColor;
  ctx.beginPath();
  ctx.moveTo(W/2 - pathTopWidth/2, 0);
  ctx.lineTo(W/2 + pathTopWidth/2, 0);
  ctx.lineTo(W/2 + pathBottomWidth/2, H);
  ctx.lineTo(W/2 - pathBottomWidth/2, H);
  ctx.closePath();
  ctx.fill();
  
  // 3. ציור קווי הפרדה בנתיבים
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 4;
  const lineSpeed = STATE.scrollSpeed * 1.5;
  for(let i=0; i<10; i++){
    const y1 = ((t * lineSpeed) + i * H * 0.2) % (H*1.2) - H*0.1;
    const y2 = y1 + H * 0.1;
    
    // פרספקטיבה לקווים
    const p1 = (y1/H); const p2 = (y2/H);
    const w1 = lerp(pathTopWidth, pathBottomWidth, p1);
    const w2 = lerp(pathTopWidth, pathBottomWidth, p2);
    
    // קו שמאלי
    ctx.beginPath();
    ctx.moveTo(W/2 - w1/3, y1);
    ctx.lineTo(W/2 - w2/3, y2);
    ctx.stroke();
    
    // קו ימני
    ctx.beginPath();
    ctx.moveTo(W/2 + w1/3, y1);
    ctx.lineTo(W/2 + w2/3, y2);
    ctx.stroke();
  }
}

/* ===================== FX ===================== */
function addExplosion(x,y,col='255,200,80'){
  for(let i=0;i<18;i++){
    STATE.fx.push({x,y, r:rand(2,5), vx:rand(-160,160), vy:rand(-220,-40), g:320, life:rand(0.4,0.9), col, a:1});
  }
  STATE.shake = Math.min(12, STATE.shake+6);
  noise({dur:0.1,vol:0.22,lp:1800});
}
function drawFX(dt){
  for(let i=STATE.fx.length-1;i>=0;i--){
    const f=STATE.fx[i];
    f.vy += f.g*dt; f.x += f.vx*dt; f.y += f.vy*dt; f.life -= dt; f.a = Math.max(0, f.life*1.5);
    ctx.fillStyle = `rgba(${f.col},${f.a})`; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,6.28); ctx.fill();
    if(f.life<=0 || f.y>H+40) STATE.fx.splice(i,1);
  }
}
function circleHit(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy < (a.r+b.r)*(a.r+b.r) }

/* ===================== Update & Draw ===================== */
let last = 0;
function loop(t){
  if(!last) last=t;
  const dt = Math.min(0.033, (t-last)/1000); last=t;
  STATE.t += dt; STATE.dt=dt;

  if (STATE.shake>0) STATE.shake = Math.max(0, STATE.shake - 60*dt);
  const sx = (Math.random()-0.5)*STATE.shake, sy = (Math.random()-0.5)*STATE.shake;
  ctx.save(); ctx.translate(sx,sy);

  drawPathAndBackground(STATE.t);

  // --- שינוי ---: לוגיקת תנועת השחקן בנתיבים
  const p = STATE.p;
  if (inputX < W * (1/3)) p.targetLane = 0;
  else if (inputX < W * (2/3)) p.targetLane = 1;
  else p.targetLane = 2;
  p.x = lerp(p.x, STATE.lanes[p.targetLane], 0.25);
  if(p.inv>0) p.inv-=dt;
  
  // צייר שחקן
  ctx.font = 'bold 36px system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('🤺', p.x, p.y + 12);
  
  p.fireTimer -= dt*1000;
  if (p.fireTimer<=0){
    playerShoot();
    p.fireTimer = (p.weapon===3 ? 40 : p.fireDelay);
  }
  
  // bullets
  for(let i=STATE.bullets.length-1;i>=0;i--){
    const b = STATE.bullets[i];
    if (b.laser){
      // (לוגיקת הלייזר נשארה דומה)
      const maxY = Math.min(p.y-26, H*0.1);
      ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(p.x, p.y-26); ctx.lineTo(p.x, maxY); ctx.stroke();
      for (const e of STATE.enemies){
        if (Math.abs(e.x - p.x) < e.r+3 && e.y < p.y-10 && e.y>maxY-30){
          e.hp -= (b.dmg*dt*60);
          e.hit = 0.1;
        }
      }
      b.t += dt;
      if (b.t>0.05) STATE.bullets.splice(i,1);
      continue;
    }
    b.x += (b.vx||0)*dt; b.y += b.vy*dt;
    if (b.rocket){
        // לוגיקת טיל (ללא שינוי)
    }
    ctx.fillStyle='#ffd65a'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,6.28); ctx.fill();
    if (b.y<-30) STATE.bullets.splice(i,1);
  }

  // spawn logic
  STATE.spawnTimer -= dt*1000;
  if (STATE.spawnTimer<=0){
    const n = 1 + (STATE.stage%3);
    for(let i=0;i<n;i++) spawnEnemy();
    if (Math.random()<0.15) {
        const lane = pick([0,1,2]);
        makePickup(STATE.lanes[lane], -20, pick(['weapon','heal','magnet']), lane);
    }
    const base = 550 - Math.min(300, STATE.stage*12);
    STATE.spawnDelay = rand(base*0.8, base*1.2);
    STATE.spawnTimer = STATE.spawnDelay;
  }

  // enemies move/draw
  for (let i=STATE.enemies.length-1;i>=0;i--){
    const e = STATE.enemies[i];
    // --- שינוי ---: האויבים רק נעים למטה עם מהירות הגלילה
    e.y += STATE.scrollSpeed * dt;
    
    if (e.hit>0) e.hit-=dt;
    
    // --- שינוי ---: ציור האויב כאייקון
    ctx.save();
    if(e.hit > 0) ctx.globalAlpha = 0.5 + Math.sin(STATE.t*80)*0.5;
    ctx.font = 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(e.icon, e.x, e.y + 16);
    ctx.restore();

    // bullets hit enemy
    for (let j=STATE.bullets.length-1;j>=0;j--){
      const b=STATE.bullets[j];
      if (b.laser) continue;
      if (circleHit(e,b)){
        e.hp -= b.dmg; e.hit=0.15; STATE.bullets.splice(j,1);
        if (e.hp<=0){
          addExplosion(e.x,e.y);
          STATE.enemies.splice(i,1);
          STATE.score += 20 + Math.floor(STATE.combo*1.5);
          if (Math.random()<0.6){ makeCoin(e.x, e.y, e.lane); }
          STATE.combo++; STATE.comboTimer = 2.2;
          // כל 20 הריגות, עליית שלב
          if (STATE.score > STATE.stage * 150){
             STATE.stage++; STATE.difficulty += 0.12; STATE.scrollSpeed += 10;
             showStory(); stageTone(STATE.stage);
             makePickup(e.x, e.y, pick(['weapon', 'heal']), e.lane);
          }
          break;
        }
      }
    }

    // collide with player
    if (circleHit(e,p) && p.inv<=0){
      damagePlayer(25);
      addExplosion(e.x, e.y, '255,80,80');
      STATE.enemies.splice(i,1);
    }

    if (e.y>H+60) STATE.enemies.splice(i,1);
  }

  // --- שינוי ---: הוסר קוד כדורי אויב כי הם לא יורים יותר

  // coins (magnet)
  for(let i=STATE.coins.length-1;i>=0;i--){
    const c=STATE.coins[i];
    c.y += STATE.scrollSpeed * dt;
    const dx = p.x - c.x, dy=p.y-c.y, d = Math.hypot(dx,dy);
    if (d < p.magnet){
      const k = clamp(1400/(d+60), 260, 1400);
      c.x += (dx/d)*k*dt; c.y += (dy/d)*k*dt;
    }
    ctx.font = '24px system-ui'; ctx.fillText('💎', c.x, c.y);
    if (circleHit(c,p)){ STATE.score += 5; STATE.coins.splice(i,1); beep({freq:820,vol:0.12,dur:0.04}); }
    else if (c.y>H+40) STATE.coins.splice(i,1);
  }

  // pickups
  for(let i=STATE.pickups.length-1;i>=0;i--){
    const a=STATE.pickups[i];
    a.y += STATE.scrollSpeed * dt;
    ctx.font = 'bold 28px system-ui';
    ctx.fillText(a.kind==='weapon'?'⚙️':a.kind==='heal'?'💖':'🧲', a.x, a.y+4);
    if (circleHit(a,p)){
      pickup(a.kind);
      STATE.pickups.splice(i,1);
    } else if (a.y>H+40) STATE.pickups.splice(i,1);
  }

  drawFX(dt);
  ctx.restore();

  if (STATE.comboTimer>0){ STATE.comboTimer -= dt; } else { STATE.combo=Math.max(0,STATE.combo-0.02); }
  hudHP.textContent = `❤️ ${Math.max(0, Math.floor(p.hp))}`;
  hudScore.textContent = `⭐ ${STATE.score}${STATE.combo>1?` ×${(1+STATE.combo*0.15).toFixed(1)}`:''}`;
  hudStage.textContent = `שלב ${STATE.stage} • 🤺 ${STATE.weaponNames[p.weapon]}`;

  if (p.hp<=0){ softReset(); }

  requestAnimationFrame(loop);
}

function damagePlayer(d){
  const p=STATE.p;
  p.hp -= d; p.inv=1.2; STATE.shake = Math.min(16, STATE.shake+10);
  noise({dur:0.12,vol:0.28,lp:1200});
}

function pickup(kind){
  const p=STATE.p;
  if (kind==='weapon'){
    p.weapon = (p.weapon+1) % 5;
    p.fireDelay = [130,120,150,30,240][p.weapon];
    p.dmg = [6,5,5,2,12][p.weapon];
    beep({type:'square',freq:720,vol:0.2}); beep({type:'square',freq:920,vol:0.18});
  } else if (kind==='heal'){
    p.hp = Math.min(p.maxHp, p.hp+28);
    beep({type:'triangle',freq:680,vol:0.18});
  } else if (kind==='magnet'){
    p.magnet = Math.min(320, p.magnet+80);
    beep({type:'sawtooth',freq:580,vol:0.16});
  }
}

function softReset(){
  addExplosion(STATE.p.x, STATE.p.y, '255,120,120');
  STATE.score = 0; // --- שינוי ---: איפוס מלא יותר, כולל ניקוד
  STATE.stage = 1;
  STATE.scrollSpeed = 280;
  STATE.p.x=W/2; STATE.p.y=H*0.85; STATE.p.targetLane=1;
  STATE.p.hp=STATE.p.maxHp; STATE.p.inv=2.0; STATE.p.weapon=0; STATE.p.magnet=160;
  STATE.enemies.length=0; STATE.coins.length=0; STATE.pickups.length=0; STATE.bullets.length=0;
  STATE.combo=0; STATE.comboTimer=0; STATE.spawnTimer=1500;
  showStory();
  stageTone(STATE.stage);
}

showStory();
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
