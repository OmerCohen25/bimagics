<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>RUN & BLAST â€” ×¨×× ×¨ ×™×¨×™ ×××›×¨</title>
<style>
  html,body{margin:0;height:100%;background:#000;touch-action:none;overscroll-behavior:none}
  canvas{display:block;width:100vw;height:100vh;background:#000}
  /* HUD ××™× ×™××œ×™ ×¦×£ (×œ× ×—×•×¡×) */
  #hud{
    position:fixed;top:0;left:0;right:0;pointer-events:none;
    display:flex;justify-content:space-between;align-items:center;
    padding:10px 12px;font-family:system-ui,Segoe UI,Arial;color:#e6edf3;mix-blend-mode:screen
  }
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 10px;font-weight:700}
  #story{position:fixed;top:52px;left:0;right:0;text-align:center;font-weight:800;letter-spacing:.5px;
    text-shadow:0 2px 12px #0008;color:#eef;opacity:0;transition:opacity .6s}
  #tips{position:fixed;bottom:10px;left:0;right:0;text-align:center;color:#c8d2e0;font-size:12px;opacity:.8;pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">
  <div class="pill" id="hp">â¤ï¸ 100</div>
  <div class="pill" id="score">â­ 0</div>
  <div class="pill" id="stage">×©×œ×‘ 1 â€¢ ğŸ”« Basic</div>
</div>
<div id="story"></div>
<div id="tips">×’×¨×¨×• ××ª ×”×’×™×‘×•×¨ ×¢× ×”××¦×‘×¢ â€” ×™×¨×™ ××•×˜×•××˜×™. ××¡×¤×• âš™ï¸ ×œ×©×“×¨×•×’ × ×©×§, ğŸ§² ××’× ×˜, ğŸ’– ×¨×™×¤×•×™. ×”×™×–×”×¨×• ××›×“×•×¨×™ ××•×™×‘!</div>

<script>
(() => {
/* ===================== Canvas & Utils ===================== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha:false });
let DPR = Math.min(2.5, window.devicePixelRatio || 1);
let W=0,H=0;
function resize(){
  W = canvas.clientWidth = window.innerWidth;
  H = canvas.clientHeight = window.innerHeight;
  canvas.width = Math.floor(W * DPR);
  canvas.height= Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
new ResizeObserver(resize).observe(document.body);
resize();

function clamp(v,a,b){return Math.max(a, Math.min(b, v))}
function lerp(a,b,t){return a+(b-a)*t}
function rand(a,b){return a + Math.random()*(b-a)}
function pick(arr){return arr[(Math.random()*arr.length)|0]}
function now(){return performance.now()}

/* ===================== Audio (WebAudio, no files) ===================== */
let audioCtx, master, canAudio=false;
function initAudio(){
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain(); master.gain.value=0.12; master.connect(audioCtx.destination);
    canAudio = true;
  } catch(e){ canAudio=false; }
}
function beep({type='square',freq=440,dur=0.07,vol=0.3,decay=0.15}={}){
  if(!canAudio) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type=type; o.frequency.value=freq;
  g.gain.value=vol; g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+Math.max(dur,0.02)+decay);
  o.connect(g); g.connect(master); o.start(); o.stop(audioCtx.currentTime+dur+decay);
}
function noise({dur=0.15,vol=0.25,lp=1200}={}){
  if(!canAudio) return;
  const buff = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
  const data = buff.getChannelData(0);
  for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*(1-i/data.length);
  const src=audioCtx.createBufferSource(); src.buffer=buff;
  const g=audioCtx.createGain(); g.gain.value=vol;
  const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp;
  src.connect(f); f.connect(g); g.connect(master);
  src.start(); src.stop(audioCtx.currentTime+dur);
}
function stageTone(stage){
  if(!canAudio) return;
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type='sine'; o.frequency.value=140 + (stage%6)*30;
  g.gain.setValueAtTime(0.0001,audioCtx.currentTime);
  g.gain.linearRampToValueAtTime(0.06, audioCtx.currentTime+0.15);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+1.0);
  o.connect(g); g.connect(master); o.start(); o.stop(audioCtx.currentTime+1.05);
}

/* ===================== Input ===================== */
let inputX = W/2, inputY = H*0.78, touching=false;
canvas.addEventListener('pointerdown',e=>{if(!audioCtx) initAudio(); touching=true; setInput(e);});
canvas.addEventListener('pointermove',e=>{ if(touching) setInput(e); });
canvas.addEventListener('pointerup',()=>touching=false);
canvas.addEventListener('pointercancel',()=>touching=false);
function setInput(e){
  const r=canvas.getBoundingClientRect();
  inputX = clamp(e.clientX - r.left, 0, W);
  inputY = clamp(e.clientY - r.top,  H*0.34, H*0.95);
}

/* ===================== Game State ===================== */
const hudHP = document.getElementById('hp');
const hudScore = document.getElementById('score');
const hudStage = document.getElementById('stage');
const storyEl = document.getElementById('story');

const STATE = {
  running:true, t:0, dt:0,
  score:0, stage:1, combo:0, comboTimer:0, difficulty:1,
  // player
  p:{ x:W/2, y:H*0.8, r:22, vx:0, vy:0, hp:100, maxHp:100, inv:0, weapon:0, magnet:140, fireDelay:130, fireTimer:0, dmg:6, speed:10 },
  bullets:[], enemyBullets:[], enemies:[], coins:[], pickups:[], fx:[],
  spawnTimer:0, spawnDelay:650,
  weaponNames:['Basic','Twin','Spread','Laser','Rocket'],
  shake:0,
};

const STORY = [
  {name:'×™×¢×¨ ×”×¢×¨×¤×œ', line:'×™×¦×•×¨×™× ×¢×ª×™×§×™× ××ª×¢×•×¨×¨×™× ××‘×™×Ÿ ×”×¢×¦×™×...'},
  {name:'×“×™×•× ×•×ª ×”××©', line:'×—×•×œ ×‘×•×¢×¨ ×•×©×•×“×“×™ ××“×‘×¨ ×˜×•×¨×¤×™× ××ª×§×¨×‘×™×.'},
  {name:'×”××–×•×¨ ×”××•×¨×‘× ×™', line:'×¨×—×•×‘×•×ª × ×˜×•×©×™×, ×“×¨×•××™×“×™× ×—××•×©×™× ××©×ª×œ×˜×™×.'},
  {name:'××¡×“×¨×•×Ÿ ×”×›×•×›×‘×™×', line:'×¨×™×§ ×—×œ×œ×™, × ×—×™×œ×™× ×–×•×”×¨×™× ××›×œ ×¢×‘×¨.'},
];

function showStory(){
  const s = STORY[(STATE.stage-1)%STORY.length];
  storyEl.innerHTML = `âŸ¡ ${s.name} âŸ¡<br/><span style="font-weight:600;opacity:.8">${s.line}</span>`;
  storyEl.style.opacity=1;
  setTimeout(()=>storyEl.style.opacity=0, 1600);
}

/* ===================== Entities ===================== */
function spawnEnemy(){
  const t = Math.random();
  const y = -40;
  let e;
  if (t<0.5){ // mob straight
    e = {type:'mob', x:rand(28,W-28), y, r:18, hp:14+STATE.stage*2, vx:0, vy: 120+STATE.stage*6, hit:0};
  } else if (t<0.75){ // zigzag
    e = {type:'zig', x:rand(40,W-40), y, r:20, hp:18+STATE.stage*2.5, vx: (Math.random()<0.5?-1:1)*(60+STATE.stage*2), vy:130+STATE.stage*8, osc:rand(0,6.28), hit:0};
  } else if (t<0.9){ // shooter
    e = {type:'gun', x:rand(40,W-40), y, r:22, hp:22+STATE.stage*3, vx:0, vy:100+STATE.stage*5, fire:rand(600,1200), hit:0};
  } else { // tank
    e = {type:'tank', x:rand(50,W-50), y, r:28, hp:50+STATE.stage*6, vx:0, vy:80+STATE.stage*3, hit:0};
  }
  STATE.enemies.push(e);
}
function spawnBoss(){
  const e={type:'boss', x:W/2, y:-80, r:52, hp: 420 + STATE.stage*90, vx:0, vy:60, fire:500, pattern:0, hit:0};
  STATE.enemies.push(e);
}
function makeCoin(x,y){
  STATE.coins.push({x,y, r:8, vy:60, t:0});
}
function makePickup(x,y,kind){
  // kinds: 'weapon','heal','magnet','power'
  STATE.pickups.push({x,y, r:14, vy:70, kind, t:0});
}

/* ===================== Weapons & Shooting ===================== */
function playerShoot(){
  const p=STATE.p;
  if (p.weapon===0){ // basic
    STATE.bullets.push({x:p.x,y:p.y-24, vx:0, vy:-520, r:4, dmg:p.dmg});
    beep({type:'square',freq:680,vol:0.18,dur:0.05});
  } else if (p.weapon===1){ // twin
    STATE.bullets.push({x:p.x-10,y:p.y-24,vx:0,vy:-540,r:4,dmg:p.dmg-1});
    STATE.bullets.push({x:p.x+10,y:p.y-24,vx:0,vy:-540,r:4,dmg:p.dmg-1});
    beep({type:'square',freq:600,vol:0.18,dur:0.05});
  } else if (p.weapon===2){ // spread
    for(let a=-0.22;a<=0.22;a+=0.22){
      STATE.bullets.push({x:p.x,y:p.y-24,vx:Math.sin(a)*220,vy:-520,r:4,dmg:p.dmg-1});
    }
    beep({type:'sawtooth',freq:560,vol:0.16,dur:0.05});
  } else if (p.weapon===3){ // laser (beam)
    // draw continuous beam using a faux "bullet" that refreshes
    STATE.bullets.push({laser:true, t:0, x:p.x, y:0, vx:0, vy:0, r:3, dmg:Math.max(1, p.dmg-3)});
    beep({type:'triangle',freq:420,vol:0.12,dur:0.04});
  } else if (p.weapon===4){ // rocket
    STATE.bullets.push({x:p.x,y:p.y-26,vx:0,vy:-360,r:6,dmg:p.dmg+6,rocket:true, turn:0});
    noise({dur:0.08,vol:0.18,lp:1400});
  }
}

/* ===================== Background Themes ===================== */
function drawParallax(t){
  const theme = (STATE.stage-1)%4; // 0 forest,1 desert,2 city,3 space
  if(theme===0){ // forest
    // sky gradient
    grad('#021','#063');
    hills(t*0.2,'#062',18, 0.6);
    hills(t*0.4,'#083',12, 0.8);
    fireflies(t);
  } else if(theme===1){ // desert
    grad('#210','#542');
    dunes(t*0.35,'#743',16,0.7);
    dunes(t*0.55,'#a65',10,0.9);
    heat(t);
  } else if(theme===2){ // city
    grad('#101022','#202044');
    skyline(t*0.25,'#1a1f34',14,0.8);
    skyline(t*0.45,'#253052',10,0.9,true);
    scanlines();
  } else { // space
    grad('#000014','#001033');
    stars(t*0.6, 0.6);
    nebulas();
  }
}
function grad(a,b){
  const g=ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,a); g.addColorStop(1,b);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
}
function hills(off,col,count,scale){
  ctx.fillStyle=col;
  for(let i=0;i<count;i++){
    const y = H*0.55 + Math.sin((i+off)*0.6)*12;
    const w = W/count * 1.8;
    ctx.beginPath();
    ctx.arc(i*(W/count)-w/2, y+40, 120*scale, 0, Math.PI*2);
    ctx.fill();
  }
}
function dunes(off,col,count,scale){
  ctx.fillStyle=col;
  for(let i=0;i<count;i++){
    const y = H*0.7 + Math.sin((i+off)*0.5)*18;
    ctx.beginPath(); ctx.ellipse(i*(W/count), y, 160*scale, 40*scale, 0, 0, 6.28); ctx.fill();
  }
}
function skyline(off,col,count,scale,lights=false){
  ctx.fillStyle=col;
  for(let i=0;i<count;i++){
    const x = i*(W/count) + (Math.sin((i+off)*0.5)*20);
    const h = H*0.2 + (Math.sin(i*0.7+off)*0.5+0.5)*H*0.35*scale;
    ctx.fillRect(x, H-h, 30+Math.random()*30, h);
  }
  if(lights){
    ctx.fillStyle='rgba(255,255,140,0.15)';
    for(let i=0;i<36;i++){
      ctx.fillRect(rand(0,W), rand(H*0.35,H*0.95), 2,2);
    }
  }
}
function stars(off,intensity){
  ctx.fillStyle=`rgba(255,255,255,${0.15*intensity})`;
  for(let i=0;i<120;i++){
    const x = (i*37.2 + (off*70))%W;
    const y = (i*91.7*intensity + (off*30))%H;
    ctx.fillRect(x, y, 2,2);
  }
}
function nebulas(){
  const g=ctx.createRadialGradient(W*0.3,H*0.4,20,W*0.6,H*0.6,420);
  g.addColorStop(0,'rgba(160,60,255,0.12)');
  g.addColorStop(1,'transparent');
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(W*0.5,H*0.5,420,0,6.28); ctx.fill();
}
function fireflies(t){
  for(let i=0;i<18;i++){
    const x=(i*97 + (t*30))%W, y=(i*53 + Math.sin(t*0.7+i)*18)%H;
    ctx.fillStyle='rgba(180,255,180,0.25)'; ctx.beginPath(); ctx.arc(x,y,2,0,6.28); ctx.fill();
  }
}
function heat(t){
  ctx.fillStyle='rgba(255,180,90,0.05)';
  for(let i=0;i<12;i++){
    const x=(i*55 + Math.sin(t*2+i)*20)%W, y=H*0.3+i*22;
    ctx.fillRect(x,y, W*0.6, 2);
  }
}
function scanlines(){
  ctx.fillStyle='rgba(255,255,255,0.02)';
  for(let i=0;i<H;i+=3){ ctx.fillRect(0,i,W,1); }
}

/* ===================== FX ===================== */
function addExplosion(x,y,col='255,200,80'){
  for(let i=0;i<18;i++){
    STATE.fx.push({x,y, r:rand(2,5), vx:rand(-160,160), vy:rand(-220,-40), g:320, life:rand(0.4,0.9), col, a:1});
  }
  STATE.shake = Math.min(12, STATE.shake+6);
  noise({dur:0.1,vol:0.22,lp:1800});
}
function drawFX(dt){
  for(let i=STATE.fx.length-1;i>=0;i--){
    const f=STATE.fx[i];
    f.vy += f.g*dt; f.x += f.vx*dt; f.y += f.vy*dt; f.life -= dt; f.a = Math.max(0, f.life*1.5);
    ctx.fillStyle = `rgba(${f.col},${f.a})`; ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,6.28); ctx.fill();
    if(f.life<=0 || f.y>H+40) STATE.fx.splice(i,1);
  }
}

/* ===================== Collisions ===================== */
function circleHit(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy < (a.r+b.r)*(a.r+b.r) }

/* ===================== Update & Draw ===================== */
let last = 0;
function loop(t){
  if(!last) last=t;
  const dt = Math.min(0.033, (t-last)/1000); last=t;
  STATE.t += dt; STATE.dt=dt;

  // screen shake
  if (STATE.shake>0) STATE.shake = Math.max(0, STATE.shake - 60*dt);
  const sx = (Math.random()-0.5)*STATE.shake, sy = (Math.random()-0.5)*STATE.shake;
  ctx.save(); ctx.translate(sx,sy);

  // background
  drawParallax(STATE.t);

  // player move
  const p = STATE.p;
  p.vx += (inputX - p.x)*0.35; p.vy += (inputY - p.y)*0.24;
  p.vx *= 0.55; p.vy *= 0.55;
  p.x = clamp(p.x + p.vx*dt*60, 24, W-24);
  p.y = clamp(p.y + p.vy*dt*60, H*0.34, H-26);
  if(p.inv>0) p.inv-=dt;

  // player fire
  p.fireTimer -= dt*1000;
  if (p.fireTimer<=0){
    playerShoot();
    // laser refresh faster
    p.fireTimer = (p.weapon===3 ? 40 : p.fireDelay);
  }

  // bullets
  for(let i=STATE.bullets.length-1;i>=0;i--){
    const b = STATE.bullets[i];
    if (b.laser){
      // draw beam
      const maxY = Math.min(p.y-26, H*0.1);
      ctx.strokeStyle='rgba(120,220,255,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(p.x, p.y-26); ctx.lineTo(p.x, maxY); ctx.stroke();
      // apply damage to enemies crossing beam
      for (const e of STATE.enemies){
        if (Math.abs(e.x - p.x) < e.r+3 && e.y < p.y-10 && e.y>maxY-30){
          e.hp -= (b.dmg*dt*60);
          e.hit = 0.1;
        }
      }
      b.t += dt;
      if (b.t>0.05) STATE.bullets.splice(i,1);
      continue;
    }
    b.x += (b.vx||0)*dt; b.y += b.vy*dt;
    // rocket seeking
    if (b.rocket){
      let target=null, best=1e9;
      for(const e of STATE.enemies){
        const d = Math.hypot(e.x-b.x, e.y-b.y);
        if(d<best){best=d; target=e;}
      }
      if (target){
        const ang = Math.atan2(target.y-b.y, target.x-b.x);
        b.vx = lerp(b.vx, Math.cos(ang)*140, 0.04);
        b.vy = lerp(b.vy, Math.sin(ang)*140, 0.04);
      }
      ctx.fillStyle='rgba(255,180,100,0.5)'; ctx.beginPath(); ctx.arc(b.x, b.y+10, 8,0,6.28); ctx.fill();
    }
    // draw bullet
    ctx.fillStyle='#ffd65a'; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,6.28); ctx.fill();
    if (b.y<-30 || b.y>H+40 || b.x<-30 || b.x>W+30) STATE.bullets.splice(i,1);
  }

  // spawn logic
  STATE.spawnTimer -= dt*1000;
  if (STATE.spawnTimer<=0){
    // spawn wave or boss
    if (STATE.score > STATE.stage * 250 && !STATE.enemies.some(e=>e.type==='boss')){
      spawnBoss(); showStory(); stageTone(STATE.stage);
    } else {
      // wave size scales
      const n = 2 + (STATE.stage%3);
      for(let i=0;i<n;i++) spawnEnemy();
      if (Math.random()<0.2) makePickup(rand(30,W-30), -20, pick(['weapon','heal','magnet','power']));
    }
    const base = 650 - Math.min(350, STATE.stage*14);
    STATE.spawnDelay = rand(base*0.75, base*1.2);
    STATE.spawnTimer = STATE.spawnDelay;
  }

  // enemies move/draw
  for (let i=STATE.enemies.length-1;i>=0;i--){
    const e = STATE.enemies[i];
    // motion
    if (e.type==='zig'){ e.osc += dt*3; e.x += Math.sin(e.osc)*(90*dt); e.y += e.vy*dt; }
    else if (e.type==='boss'){ e.y += e.vy*dt; e.x = clamp(e.x + Math.sin(STATE.t*1.3)*120*dt, 40, W-40); }
    else { e.y += e.vy*dt; e.x = clamp(e.x + (e.vx||0)*dt, 20, W-20); }

    // draw body + icon face
    const baseCol = e.type==='tank' ? '#8a3' : e.type==='boss' ? '#e44' : e.type==='gun' ? '#6cf' : '#f78';
    const body = e.hit>0 ? '#fff' : baseCol; if (e.hit>0) e.hit-=dt;
    ctx.fillStyle=body; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,6.28); ctx.fill();
    // eyes
    ctx.fillStyle='#1a2030'; ctx.beginPath(); ctx.arc(e.x-e.r*0.35, e.y-e.r*0.2, Math.max(2,e.r*0.18), 0, 6.28);
    ctx.arc(e.x+e.r*0.35, e.y-e.r*0.2, Math.max(2,e.r*0.18), 0, 6.28); ctx.fill();
    // mouth
    ctx.strokeStyle='#1a2030'; ctx.lineWidth=2; ctx.beginPath();
    ctx.arc(e.x, e.y+e.r*0.15, e.r*0.4, 0.2, Math.PI-0.2); ctx.stroke();

    // shooter fires
    if ((e.type==='gun' || e.type==='boss')){
      e.fire -= dt*1000;
      if (e.fire<=0 && e.y>H*0.12){
        if (e.type==='boss'){
          // spread pattern
          const shots = 8; const spd = 160+STATE.stage*8;
          for(let k=0;k<shots;k++){
            const ang = (k/shots)*Math.PI + Math.sin(STATE.t*2)*0.2;
            STATE.enemyBullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, r:4});
          }
          e.fire = 340;
        } else {
          const ang = Math.atan2(STATE.p.y-e.y, STATE.p.x-e.x);
          STATE.enemyBullets.push({x:e.x, y:e.y, vx:Math.cos(ang)*260, vy:Math.sin(ang)*260, r:4});
          e.fire = rand(800,1400);
        }
        beep({type:'triangle',freq:240,vol:0.12,dur:0.05});
      }
    }

    // bullets hit enemy
    for (let j=STATE.bullets.length-1;j>=0;j--){
      const b=STATE.bullets[j];
      if (b.laser) continue;
      if (circleHit(e,b)){
        e.hp -= b.dmg; e.hit=0.15; STATE.bullets.splice(j,1);
        if (e.hp<=0){
          addExplosion(e.x,e.y);
          STATE.enemies.splice(i,1);
          STATE.score += (e.type==='boss'?120:20) + Math.floor(STATE.combo*1.5);
          // loot
          if (Math.random()<0.6){ makeCoin(e.x, e.y); }
          if (e.type==='boss'){ // stage up
            STATE.stage++; STATE.difficulty += 0.12;
            showStory(); stageTone(STATE.stage);
            // reward
            if(Math.random()<0.7) makePickup(e.x, e.y, pick(['weapon','power','heal','magnet']));
          }
          // combo
          STATE.combo++; STATE.comboTimer = 2.2;
          break;
        }
      }
    }

    // collide with player
    if (circleHit(e,p) && p.inv<=0){
      damagePlayer(18);
      STATE.enemies.splice(i,1);
    }

    // out
    if (e.y>H+60) STATE.enemies.splice(i,1);
  }

  // enemy bullets
  ctx.fillStyle='#ff6570';
  for (let i=STATE.enemyBullets.length-1;i>=0;i--){
    const b=STATE.enemyBullets[i];
    b.x += b.vx*dt; b.y += b.vy*dt;
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,6.28); ctx.fill();
    if (circleHit(b,p) && p.inv<=0){
      damagePlayer(10);
      STATE.enemyBullets.splice(i,1);
    }
    if (b.x<-40||b.x>W+40||b.y<-40||b.y>H+80) STATE.enemyBullets.splice(i,1);
  }

  // coins (magnet)
  for(let i=STATE.coins.length-1;i>=0;i--){
    const c=STATE.coins[i];
    c.t += dt; c.y += c.vy*dt;
    const dx = p.x - c.x, dy=p.y-c.y, d = Math.hypot(dx,dy);
    if (d < p.magnet){
      const k = clamp(1400/(d+60), 260, 1400);
      c.x += (dx/d)*k*dt; c.y += (dy/d)*k*dt;
    }
    // draw
    ctx.fillStyle='rgba(249,199,79,0.95)'; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,6.28); ctx.fill();
    ctx.strokeStyle='#9b6b11'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(c.x,c.y,c.r-2,0,6.28); ctx.stroke();
    if (circleHit(c,p)){ STATE.score += 5 + Math.floor(STATE.combo); STATE.coins.splice(i,1); beep({freq:820,vol:0.12,dur:0.04}); }
    else if (c.y>H+40) STATE.coins.splice(i,1);
  }

  // pickups
  for(let i=STATE.pickups.length-1;i>=0;i--){
    const a=STATE.pickups[i];
    a.t+=dt; a.y += a.vy*dt* (1.0 + Math.sin(a.t*3)*0.02);
    // draw icon
    ctx.fillStyle = a.kind==='weapon'?'#8ef' : a.kind==='heal'?'#6f6' : a.kind==='magnet'?'#9cf' : '#fc8';
    ctx.beginPath(); ctx.arc(a.x,a.y,a.r,0,6.28); ctx.fill();
    ctx.fillStyle='#0b0f1a'; ctx.font='bold 12px system-ui'; ctx.textAlign='center';
    ctx.fillText(a.kind==='weapon'?'âš™ï¸':a.kind==='heal'?'ğŸ’–':a.kind==='magnet'?'ğŸ§²':'ğŸ’¥', a.x, a.y+4);
    if (circleHit(a,p)){
      pickup(a.kind);
      STATE.pickups.splice(i,1);
    } else if (a.y>H+40) STATE.pickups.splice(i,1);
  }

  // FX
  drawFX(dt);

  ctx.restore(); // end shake translate

  // HUD
  if (STATE.comboTimer>0){ STATE.comboTimer -= dt; } else { STATE.combo=Math.max(0,STATE.combo-0.02); }
  hudHP.textContent = `â¤ï¸ ${Math.max(0, Math.floor(p.hp))}`;
  hudScore.textContent = `â­ ${STATE.score}${STATE.combo>1?` Ã—${(1+STATE.combo*0.15).toFixed(1)}`:''}`;
  hudStage.textContent = `×©×œ×‘ ${STATE.stage} â€¢ ğŸ”« ${STATE.weaponNames[p.weapon]}`;

  // death?
  if (p.hp<=0){
    // quick soft reset
    softReset();
  }

  requestAnimationFrame(loop);
}

function damagePlayer(d){
  const p=STATE.p;
  p.hp -= d; p.inv=0.9; STATE.shake = Math.min(16, STATE.shake+8);
  noise({dur:0.12,vol:0.28,lp:1200});
}
function pickup(kind){
  const p=STATE.p;
  if (kind==='weapon'){
    p.weapon = (p.weapon+1) % 5; // rotate through weapons
    p.fireDelay = [130,120,150,30,240][p.weapon];
    p.dmg = [6,5,5,2,12][p.weapon];
    beep({type:'square',freq:720,vol:0.2}); beep({type:'square',freq:920,vol:0.18});
  } else if (kind==='heal'){
    p.hp = Math.min(p.maxHp, p.hp+28);
    beep({type:'triangle',freq:680,vol:0.18});
  } else if (kind==='magnet'){
    p.magnet = Math.min(320, p.magnet+80);
    beep({type:'sawtooth',freq:580,vol:0.16});
  } else if (kind==='power'){
    // temporary power surge
    STATE.combo += 4; STATE.comboTimer = 3.5;
    addExplosion(p.x,p.y-20,'120,220,255');
  }
}

function softReset(){
  // small "continue" vibe: keep score/stage, reset player & clear bullets
  addExplosion(STATE.p.x, STATE.p.y, '255,120,120');
  STATE.p.x=W/2; STATE.p.y=H*0.82; STATE.p.vx=0; STATE.p.vy=0;
  STATE.p.hp=STATE.p.maxHp; STATE.p.inv=1.5; STATE.p.weapon=0; STATE.p.magnet=160;
  STATE.bullets.length=0; STATE.enemyBullets.length=0; STATE.enemies.length=0; STATE.coins.length=0; STATE.pickups.length=0;
  STATE.combo=0; STATE.comboTimer=0; STATE.spawnTimer=400;
  showStory();
  stageTone(STATE.stage);
}

/* ===================== Start ===================== */
showStory();
requestAnimationFrame(loop);
})();
</script>
</body>
</html>