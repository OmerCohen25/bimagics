<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>×¡× ×™×™×§ ×˜×•×¨×‘×•</title>
    <style>
        :root {
            --primary-color: #00ff88;
            --dark-color: #1a1a1a;
            --background-color: #111;
        }

        /* --- ×¡×’× ×•× ×•×ª ×›×œ×œ×™×™× --- */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: var(--dark-color);
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none; /* ××•× ×¢ ×”×ª× ×”×’×•×ª ×‘×¨×™×¨×ª ××—×“×œ ×©×œ ××’×¢ ×›××• ×–×•× */
        }

        #gameContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: var(--background-color);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        /* --- ××¡×›×™ ×××©×§ --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 100;
            padding: 20px;
            box-sizing: border-box;
        }

        .screen h1 {
            font-size: 3rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            text-shadow: 0 0 10px var(--primary-color);
        }

        .screen p {
            font-size: 1.1rem;
            max-width: 500px;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .instructions {
            font-size: 1rem;
            text-align: right;
            max-width: 300px;
            margin: 0 auto 25px auto;
        }

        .button {
            padding: 15px 30px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--dark-color);
            background-color: var(--primary-color);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
            user-select: none;
        }

        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.6);
        }
        
        #gameOverScreen .button {
            margin-top: 15px;
        }

        #finalScore, #finalLevel {
            font-weight: bold;
            color: var(--primary-color);
        }

        .hidden {
            display: none;
        }

        /* --- ×›×¤×ª×•×¨×™ ×©×œ×™×˜×” --- */
        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 50;
            pointer-events: none; /* ×××¤×©×¨ ×œ×—×™×¦×•×ª ×œ×¢×‘×•×¨ ×“×¨×š ×”×§×•× ×˜×™×™× ×¨ */
        }

        /* D-Pad */
        #dpad-container {
            position: relative;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
        }
        .dpad-btn:active {
            background-color: rgba(0, 255, 136, 0.7);
        }
        #dpad-up    { top: 0; left: 50px; }
        #dpad-down  { bottom: 0; left: 50px; }
        #dpad-left  { top: 50px; left: 0; }
        #dpad-right { top: 50px; right: 0; }

        /* Joystick */
        #joystick-base {
            position: relative;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            pointer-events: auto;
        }

        #joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
            cursor: grab;
            user-select: none;
        }
        #joystick-handle:active {
            cursor: grabbing;
        }

        /* --- ×›×¤×ª×•×¨ ×¡××•× ×“ --- */
        #soundToggle {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 2rem;
            cursor: pointer;
            z-index: 120;
            background: none;
            border: none;
            color: white;
            padding: 5px;
            user-select: none;
        }
    </style>
</head>
<body>

    <div id="startScreen" class="screen">
        <h1>×¡× ×™×™×§ ×˜×•×¨×‘×• ğŸâš¡ï¸</h1>
        <p>×”×’×¨×¡×” ×”××©×•×“×¨×’×ª ×©×œ ×¡× ×™×™×§! ××¡×¤×• ×¤×¨×™×˜×™×, ×”×ª×—××§×• ×××›×©×•×œ×™× ×•×”×©×™×’×• ××ª ×”× ×™×§×•×“ ×”×’×‘×•×” ×‘×™×•×ª×¨.</p>
        <div class="instructions">
            <b>ğŸ ×ª×¤×•×—:</b> +1 × ×§×•×“×”<br>
            <b>ğŸ’° ××˜×‘×¢:</b> +5 × ×§×•×“×•×ª<br>
            <b>ğŸŒ¶ï¸ ×¤×œ×¤×œ:</b> ×‘×•×¡×˜ ××”×™×¨×•×ª ×–×× ×™<br>
            <b>ğŸ›¡ï¸ ××’×Ÿ:</b> ×—×¡×™× ×•×ª ×–×× ×™×ª ××¤×’×™×¢×•×ª<br>
            <b>âœ‚ï¸ ××¡×¤×¨×™×™×:</b> ××§×¦×¨ ××ª ×”× ×—×©<br>
            <b>ğŸ§Š ×§×¨×—:</b> ×××˜ ××•×ª×š! ×”×™×× ×¢!<br>
            <b>ğŸ§± ××›×©×•×œ / ğŸŒ ××•×™×‘:</b> ×¤×’×™×¢×” ×§×˜×œ× ×™×ª!
        </div>
        <button id="startButton" class="button">×”×ª×—×œ ××©×—×§</button>
    </div>

    <div id="gameOverScreen" class="screen hidden">
        <h1>×”××©×—×§ × ×’××¨!</h1>
        <p>× ×™×§×•×“ ×¡×•×¤×™: <span id="finalScore">0</span></p>
        <p>×©×œ×‘ ×¡×•×¤×™: <span id="finalLevel">1</span></p>
        <button id="restartButton" class="button">×©×—×§ ×©×•×‘</button>
        <button id="shareButton" class="button">×©×ª×£ ×ª×•×¦××” ğŸ“²</button>
    </div>

    <button id="soundToggle">ğŸ”Š</button>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div id="dpad-container">
                <div id="dpad-up" class="dpad-btn">â–²</div>
                <div id="dpad-down" class="dpad-btn">â–¼</div>
                <div id="dpad-left" class="dpad-btn">â—€</div>
                <div id="dpad-right" class="dpad-btn">â–¶</div>
            </div>
            <div id="joystick-base">
                <div id="joystick-handle"></div>
            </div>
        </div>
    </div>


    <script>
        // ===============================================
        //           ××ª×—×•×œ ××©×ª× ×™× ×•×§×‘×•×¢×™×
        // ===============================================

        // ×”×¤× ×™×•×ª ×œ-DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const shareButton = document.getElementById('shareButton');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalLevelDisplay = document.getElementById('finalLevel');
        const soundToggleButton = document.getElementById('soundToggle');

        // ×”×’×“×¨×•×ª ××©×—×§
        const TILE_SIZE = 20;
        let tileCountX, tileCountY;

        // ××©×ª× ×™ ××¦×‘ ××©×—×§
        let gameState = 'start';
        let score = 0;
        let level = 1;
        let isMuted = false;

        // ××©×ª× ×™ ×‘×§×¨×ª ×”××©×—×§
        let snake, items, obstacles, enemies;
        let gameLoopTimeout;
        let baseSpeed = 150;
        let currentSpeed = baseSpeed;

        // ×˜×™×™××¨×™× ×œ×›×•×—×•×ª-×¢×œ
        let powerUpTimers = {
            speedBoost: 0,
            shield: 0
        };

        // ===============================================
        //               ×¡××•× ×“ (Base64)
        // ===============================================
        let audioContext;
        const sounds = {
            eat: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=',
            powerup: 'data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBAAAAABAAIARKwAAIhYAQACABAAZGF0YSgAAABo/8C/hP+E/4T/hP+E/4T/hP+E/4T/hP+E/4T/hP+E/4T/hP+E/4T/hP+E',
            hit: 'data:audio/wav;base64,UklGRiwaAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YRIWAACAgICAAAAAgIA='
        };
        async function playSound(soundName) {
            if (isMuted || !sounds[soundName]) return;
            try {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const response = await fetch(sounds[soundName]);
                const audioBuffer = await audioContext.decodeAudioData(await response.arrayBuffer());
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start(0);
            } catch (e) { console.error("×©×’×™××” ×‘× ×™×’×•×Ÿ ×¡××•× ×“:", e); }
        }
        
        // ===============================================
        //             ××—×œ×§×•×ª ×”××©×—×§ (Classes)
        // ===============================================

        class Snake {
            constructor() {
                this.body = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
            }

            move() {
                this.direction = this.nextDirection;
                const head = { x: this.body[0].x + this.direction.x, y: this.body[0].y + this.direction.y };
                this.body.unshift(head);
                this.body.pop();
            }
            
            grow(amount = 1) {
                 for(let i = 0; i < amount; i++) {
                    this.body.push({ ...this.body[this.body.length - 1] });
                 }
            }
            
            shorten() {
                if (this.body.length > 3) {
                   this.body.splice(-Math.min(3, this.body.length - 2)); // ×”×¡×¨ ×¢×“ 3 ×—×œ×§×™×, ×”×©××¨ ×œ×¤×—×•×ª 2
                }
            }

            changeDirection(x, y) {
                if (this.direction.x === -x && this.direction.y === -y) return;
                this.nextDirection = { x, y };
            }

            draw(ctx) {
                // ××¤×§×˜ ××’×Ÿ
                if (powerUpTimers.shield > 0) {
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(
                        this.body[0].x * TILE_SIZE + TILE_SIZE / 2, 
                        this.body[0].y * TILE_SIZE + TILE_SIZE / 2,
                        TILE_SIZE * 0.8, 0, 2 * Math.PI
                    );
                    ctx.fill();
                }
                
                // ×¦×™×•×¨ ×”× ×—×©
                ctx.font = `${TILE_SIZE * 1.2}px Arial`;
                ctx.fillText('ğŸ', this.body[0].x * TILE_SIZE - TILE_SIZE*0.1, this.body[0].y * TILE_SIZE + TILE_SIZE*0.9);
                
                ctx.fillStyle = powerUpTimers.speedBoost > 0 ? '#ffae00' : '#00dd00';
                for (let i = 1; i < this.body.length; i++) {
                    ctx.beginPath();
                    ctx.arc(
                        this.body[i].x * TILE_SIZE + TILE_SIZE / 2, 
                        this.body[i].y * TILE_SIZE + TILE_SIZE / 2,
                        TILE_SIZE / 2.5 - (i/this.body.length), 0, 2 * Math.PI
                    );
                    ctx.fill();
                }
            }
            
            checkCollision(obstacles, enemies) {
                const head = this.body[0];
                const isShielded = powerUpTimers.shield > 0;

                // ×”×ª× ×’×©×•×ª ×‘×§×™×¨×•×ª (××œ× ×× ×™×© ××’×Ÿ)
                if (!isShielded && (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY)) {
                    return true;
                }
                
                // ×”×ª× ×’×©×•×ª ×¢×¦××™×ª (××œ× ×× ×™×© ××’×Ÿ)
                if (!isShielded) {
                    for (let i = 1; i < this.body.length; i++) {
                        if (head.x === this.body[i].x && head.y === this.body[i].y) return true;
                    }
                }
                
                // ×”×ª× ×’×©×•×ª ×‘××›×©×•×œ×™× (××œ× ×× ×™×© ××’×Ÿ)
                if (!isShielded && obstacles.some(ob => ob.x === head.x && ob.y === head.y)) {
                    return true;
                }
                
                // ×”×ª× ×’×©×•×ª ×‘××•×™×‘×™× (××œ× ×× ×™×© ××’×Ÿ)
                if (!isShielded && enemies.some(en => en.x === head.x && en.y === head.y)) {
                    return true;
                }
                return false;
            }
        }
        
        class Item {
            constructor(type, emoji, effect) {
                this.type = type;
                this.emoji = emoji;
                this.effect = effect;
                this.spawn();
            }

            spawn() {
                const allObjects = [...snake.body, ...items.map(i => ({x:i.x, y:i.y})), ...obstacles, ...enemies];
                let validPosition = false;
                while (!validPosition) {
                    this.x = Math.floor(Math.random() * tileCountX);
                    this.y = Math.floor(Math.random() * tileCountY);
                    validPosition = !allObjects.some(obj => obj.x === this.x && obj.y === this.y);
                }
            }

            draw(ctx) {
                ctx.font = `${TILE_SIZE}px Arial`;
                ctx.fillText(this.emoji, this.x * TILE_SIZE, this.y * TILE_SIZE + TILE_SIZE);
            }
        }

        class Obstacle {
             constructor() { this.spawn(); }
             spawn() {
                 // ×–×”×” ×œ-Item.spawn
                 const allObjects = [...snake.body, ...items.map(i => ({x:i.x, y:i.y})), ...obstacles, ...enemies];
                 let validPosition = false;
                 while (!validPosition) {
                     this.x = Math.floor(Math.random() * tileCountX);
                     this.y = Math.floor(Math.random() * tileCountY);
                     validPosition = !allObjects.some(obj => obj.x === this.x && obj.y === this.y);
                 }
             }
             draw(ctx) {
                 ctx.font = `${TILE_SIZE}px Arial`;
                 ctx.fillText('ğŸ§±', this.x * TILE_SIZE, this.y * TILE_SIZE + TILE_SIZE);
             }
        }
        
        class Enemy {
             constructor() { this.spawn(); }
             spawn() {
                 // ×–×”×” ×œ-Item.spawn
                 const allObjects = [...snake.body, ...items.map(i => ({x:i.x, y:i.y})), ...obstacles, ...enemies];
                 let validPosition = false;
                 while (!validPosition) {
                     this.x = Math.floor(Math.random() * tileCountX);
                     this.y = Math.floor(Math.random() * tileCountY);
                     validPosition = !allObjects.some(obj => obj.x === this.x && obj.y === this.y);
                 }
             }
            move() {
                // ×ª× ×•×¢×” ××§×¨××™×ª ×¤×©×•×˜×”
                const move = Math.random();
                if (move < 0.25 && this.x > 0) this.x--;
                else if (move < 0.5 && this.x < tileCountX - 1) this.x++;
                else if (move < 0.75 && this.y > 0) this.y--;
                else if (this.y < tileCountY - 1) this.y++;
            }
             draw(ctx) {
                 ctx.font = `${TILE_SIZE}px Arial`;
                 ctx.fillText('ğŸŒ', this.x * TILE_SIZE, this.y * TILE_SIZE + TILE_SIZE);
             }
        }

        // ===============================================
        //             ×¤×•× ×§×¦×™×•×ª ×œ×™×‘×” ×©×œ ×”××©×—×§
        // ===============================================

        function initGame() {
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
            const canvasSize = Math.floor(size / TILE_SIZE) * TILE_SIZE;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            
            // ×”×ª×××ª ×’×•×“×œ ×”×§×•× ×˜×™×™× ×¨ ×”×¨××©×™
            const gameContainer = document.getElementById('gameContainer');
            gameContainer.style.width = `${canvas.width}px`;
            gameContainer.style.height = `${canvas.height}px`;

            tileCountX = canvas.width / TILE_SIZE;
            tileCountY = canvas.height / TILE_SIZE;

            score = 0;
            level = 1;
            baseSpeed = 150;
            powerUpTimers = { speedBoost: 0, shield: 0 };
            
            snake = new Snake();
            items = [new Item('food', 'ğŸ', () => { score++; snake.grow(); playSound('eat'); })];
            obstacles = [];
            enemies = [];
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            updateGame();
            drawGame();
            
            // ×—×™×©×•×‘ ××”×™×¨×•×ª
            let speedModifier = 1;
            if (powerUpTimers.speedBoost > 0) speedModifier = 0.5;
            if (powerUpTimers.slowDown > 0) speedModifier = 1.5;
            currentSpeed = baseSpeed * speedModifier;

            clearTimeout(gameLoopTimeout);
            gameLoopTimeout = setTimeout(gameLoop, currentSpeed);
        }
        
        function updateGame() {
            snake.move();
            enemies.forEach(en => en.move());

            // × ×™×”×•×œ ×˜×™×™××¨×™×
            for (const key in powerUpTimers) {
                if (powerUpTimers[key] > 0) powerUpTimers[key] -= baseSpeed;
            }

            // ×‘×“×™×§×ª ×”×ª× ×’×©×•×™×•×ª
            if (snake.checkCollision(obstacles, enemies)) {
                endGame();
                return;
            }

            // ×‘×“×™×§×ª ××›×™×œ×ª ×¤×¨×™×˜×™×
            const head = snake.body[0];
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (head.x === item.x && head.y === item.y) {
                    item.effect();
                    items.splice(i, 1); // ×”×¡×¨×ª ×”×¤×¨×™×˜ ×©× ××›×œ
                }
            }

            // × ×™×”×•×œ ×¢×œ×™×™×ª ×¨××•×ª ×•×¡×¤××•××™× ×’
            manageLevelAndSpawns();
        }

        function manageLevelAndSpawns() {
             const newLevel = Math.floor(score / 10) + 1;
             if (newLevel > level) {
                level = newLevel;
                baseSpeed = Math.max(60, 150 - (level * 5));
                // ×”×•×¡×¤×ª ××›×©×•×œ ×—×“×© ×‘×›×œ ×¢×œ×™×™×ª ×©×œ×‘ (×”×—×œ ××©×œ×‘ 2)
                if (level > 1 && obstacles.length < level * 2) {
                    obstacles.push(new Obstacle());
                }
                // ×”×•×¡×¤×ª ××•×™×‘ ×—×“×© ×›×œ 2 ×©×œ×‘×™× (×”×—×œ ××©×œ×‘ 3)
                if (level > 2 && level % 2 !== 0 && enemies.length < Math.floor(level/2)) {
                    enemies.push(new Enemy());
                }
             }
             
             // ×¡×¤××•×Ÿ ×¤×¨×™×˜×™× ×¨× ×“×•××œ×™
             if (Math.random() < 0.015 && items.length < 5) {
                 spawnRandomItem();
             }
             // ×ª××™×“ ×œ×•×•×“× ×©×™×© ×œ×¤×—×•×ª ×ª×¤×•×— ××—×“
             if (!items.some(i => i.type === 'food')) {
                  items.push(new Item('food', 'ğŸ', () => { score++; snake.grow(); playSound('eat'); }));
             }
        }
        
        function spawnRandomItem() {
            const itemTypes = [
                { type: 'gold', emoji: 'ğŸ’°', effect: () => { score += 5; snake.grow(); playSound('powerup'); } },
                { type: 'speed', emoji: 'ğŸŒ¶ï¸', effect: () => { powerUpTimers.speedBoost = 5000; powerUpTimers.slowDown = 0; playSound('powerup'); } },
                { type: 'shield', emoji: 'ğŸ›¡ï¸', effect: () => { powerUpTimers.shield = 5000; playSound('powerup'); } },
                { type: 'scissors', emoji: 'âœ‚ï¸', effect: () => { snake.shorten(); playSound('powerup'); } },
                { type: 'ice', emoji: 'ğŸ§Š', effect: () => { powerUpTimers.slowDown = 3000; powerUpTimers.speedBoost = 0; playSound('hit'); } }
            ];
            const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            items.push(new Item(randomType.type, randomType.emoji, randomType.effect));
        }

        function drawGame() {
            ctx.fillStyle = var(--background-color);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            items.forEach(item => item.draw(ctx));
            obstacles.forEach(ob => ob.draw(ctx));
            enemies.forEach(en => en.draw(ctx));
            snake.draw(ctx);
            drawHUD();
        }

        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`× ×™×§×•×“: ${score}`, 10, 25);
            ctx.textAlign = 'right';
            ctx.fillText(`×©×œ×‘: ${level}`, canvas.width - 10, 25);
            
            // ×¦×™×•×¨ ×˜×™×™××¨×™× ×©×œ ×›×•×—×•×ª-×¢×œ
            let hudY = 50;
            if (powerUpTimers.shield > 0) {
                ctx.fillText(`ğŸ›¡ï¸ ${Math.ceil(powerUpTimers.shield/1000)}s`, canvas.width - 10, hudY);
                hudY += 25;
            }
             if (powerUpTimers.speedBoost > 0) {
                ctx.fillText(`ğŸŒ¶ï¸ ${Math.ceil(powerUpTimers.speedBoost/1000)}s`, canvas.width - 10, hudY);
            }
             if (powerUpTimers.slowDown > 0) {
                ctx.fillText(`ğŸ§Š ${Math.ceil(powerUpTimers.slowDown/1000)}s`, canvas.width - 10, hudY);
            }
        }

        function startGame() {
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            initGame();
            gameLoop();
        }

        function endGame() {
            playSound('hit');
            gameState = 'gameOver';
            clearTimeout(gameLoopTimeout);
            finalScoreDisplay.textContent = score;
            finalLevelDisplay.textContent = level;
            gameOverScreen.classList.remove('hidden');
        }

        // ===============================================
        //              ×‘×§×¨×ª ××©×—×§ (Events)
        // ===============================================
        
        function setupControls() {
            // ××§×œ×“×ª
            window.addEventListener('keydown', e => {
                if (gameState !== 'playing') return;
                switch (e.key) {
                    case 'ArrowUp': case 'w': snake.changeDirection(0, -1); break;
                    case 'ArrowDown': case 's': snake.changeDirection(0, 1); break;
                    case 'ArrowLeft': case 'a': snake.changeDirection(-1, 0); break;
                    case 'ArrowRight': case 'd': snake.changeDirection(1, 0); break;
                }
            });

            // ×”×—×œ×§×” (Swipe)
            let touchStartX = 0, touchStartY = 0;
            canvas.addEventListener('touchstart', e => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            canvas.addEventListener('touchend', e => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;
                if (Math.max(Math.abs(dx), Math.abs(dy)) > 30) {
                    if (Math.abs(dx) > Math.abs(dy)) snake.changeDirection(dx > 0 ? 1 : -1, 0);
                    else snake.changeDirection(0, dy > 0 ? 1 : -1);
                }
            }, { passive: true });
            
            // D-Pad
            const dpadSetup = (id, x, y) => document.getElementById(id).addEventListener('touchstart', (e) => { e.preventDefault(); snake.changeDirection(x, y); }, { passive: false });
            dpadSetup('dpad-up', 0, -1);
            dpadSetup('dpad-down', 0, 1);
            dpadSetup('dpad-left', -1, 0);
            dpadSetup('dpad-right', 1, 0);

            // Joystick
            const joystickHandle = document.getElementById('joystick-handle');
            const joystickBase = document.getElementById('joystick-base');
            let isJoystickActive = false;
            let joystickCenterX, joystickCenterY, joystickRadius;
            
            function onJoystickStart(e) {
                e.preventDefault();
                isJoystickActive = true;
                const rect = joystickBase.getBoundingClientRect();
                joystickCenterX = rect.left + rect.width / 2;
                joystickCenterY = rect.top + rect.height / 2;
                joystickRadius = rect.width / 2;
                joystickHandle.style.transition = 'none';
            }

            function onJoystickMove(e) {
                if (!isJoystickActive) return;
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                let dx = touch.clientX - joystickCenterX;
                let dy = touch.clientY - joystickCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > joystickRadius) {
                    dx = (dx / distance) * joystickRadius;
                    dy = (dy / distance) * joystickRadius;
                }

                joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;

                const angle = Math.atan2(dy, dx);
                if (Math.abs(dx) > Math.abs(dy)) {
                    snake.changeDirection(dx > 0 ? 1 : -1, 0);
                } else {
                    snake.changeDirection(0, dy > 0 ? 1 : -1);
                }
            }

            function onJoystickEnd(e) {
                if (!isJoystickActive) return;
                e.preventDefault();
                isJoystickActive = false;
                joystickHandle.style.transition = 'transform 0.2s ease';
                joystickHandle.style.transform = 'translate(0, 0)';
            }
            
            joystickBase.addEventListener('mousedown', onJoystickStart);
            window.addEventListener('mousemove', onJoystickMove);
            window.addEventListener('mouseup', onJoystickEnd);
            joystickBase.addEventListener('touchstart', onJoystickStart, { passive: false });
            window.addEventListener('touchmove', onJoystickMove, { passive: false });
            window.addEventListener('touchend', onJoystickEnd, { passive: false });
        }
        
        // ×¤×•× ×§×¦×™×™×ª ×©×™×ª×•×£
        async function shareScore() {
            const gameName = "×¡× ×™×™×§ ×˜×•×¨×‘×• ğŸâš¡ï¸";
            const shareText = `×”×©×’×ª×™ × ×™×§×•×“ ${score} ×‘×©×œ×‘ ${level} ×‘${gameName}! × ×¡×• ×œ× ×¦×— ××•×ª×™:`;
            const shareUrl = "https://bimagics.com/games/chicken.html";

            if (navigator.share) {
                try {
                    await navigator.share({ title: gameName, text: shareText, url: shareUrl });
                } catch (err) { console.error('×©×’×™××” ×‘×©×™×ª×•×£:', err); }
            } else {
                try {
                    await navigator.clipboard.writeText(`${shareText}\n${shareUrl}`);
                    alert('×”×ª×•×¦××” ×•×”×§×™×©×•×¨ ×”×•×¢×ª×§×• ×œ×œ×•×—!');
                } catch (err) { alert('×œ× × ×™×ª×Ÿ ×”×™×” ×œ×”×¢×ª×™×§ ××ª ×”×ª×•×¦××”.'); }
            }
        }
        
        // ×—×™×‘×•×¨ ××™×¨×•×¢×™× ×•×¤×¢×•×œ×•×ª
        startButton.addEventListener('click', () => {
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            startGame();
        });
        restartButton.addEventListener('click', startGame);
        shareButton.addEventListener('click', shareScore);
        soundToggleButton.addEventListener('click', () => {
            isMuted = !isMuted;
            soundToggleButton.textContent = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
        });
        window.addEventListener('resize', () => { if (gameState !== 'playing') initGame(); });
        
        // ××ª×—×•×œ ×¨××©×•× ×™
        setupControls();
        initGame();

    </script>
</body>
</html>
