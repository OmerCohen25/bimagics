<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2048 - Ultimate Edition</title>
    <style>
        :root {
            --grid-size: 4;
            --grid-gap: 15px;
            --board-bg: #bbada0;
            --cell-bg: #ccc0b3;
            --text-color-dark: #776e65;
            --text-color-light: #f9f6f2;
            --bg-color: #faf8ef;
            --border-radius: 5px;
        }

        /* Prevents all scrolling and annoying mobile browser UI behaviors */
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            margin: 0;
            position: fixed;
        }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            text-align: center;
            background-color: var(--bg-color);
            color: var(--text-color-dark);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 10px 0;
            font-weight: bold;
        }

        /* --- Setup Screen --- */
        #setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #setup-screen h2 { font-size: 2rem; }

        #size-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 400px;
        }

        .action-button {
            padding: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            background-color: #8f7a66;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .size-button { font-size: 1.5rem; padding: 20px; }
        .action-button:hover, .size-button:hover { background-color: #9f8b77; }

        /* --- Game Area --- */
        #game-area {
            display: none;
            flex-direction: column;
            align-items: center;
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: clamp(300px, 90vw, 500px);
            margin-bottom: 10px;
        }

        .score-box {
            background-color: var(--board-bg);
            color: white;
            padding: 5px 15px;
            border-radius: var(--border-radius);
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            min-width: 80px;
        }
        .score-box .label {
            font-size: 0.8rem;
            color: #eee4da;
        }

        #board-container {
            position: relative;
            width: clamp(300px, 90vw, 500px);
            height: clamp(300px, 90vw, 500px);
            background-color: var(--board-bg);
            border-radius: var(--border-radius);
            padding: var(--grid-gap);
            box-sizing: border-box;
        }

        .grid-cell {
            position: absolute;
            background-color: var(--cell-bg);
            border-radius: var(--border-radius);
        }
        
        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: var(--border-radius);
            font-weight: bold;
            font-size: 2.5rem;
            /* The magic: transition the transform property for smooth movement */
            transition: transform 100ms ease-in-out;
        }
        
        /* Font size adjustments based on grid size */
        :root[data-grid-size='5'] .tile, :root[data-grid-size='6'] .tile { font-size: 1.8rem; }
        :root[data-grid-size='7'] .tile, :root[data-grid-size='8'] .tile { font-size: 1.2rem; }
        :root[data-grid-size='9'] .tile, :root[data-grid-size='10'] .tile { font-size: 1.0rem; }
        
        @keyframes appear { from { transform: scale(0); } to { transform: scale(1); } }
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        /* Tile Colors */
        .tile[data-value="2"]    { background: #eee4da; color: var(--text-color-dark); }
        .tile[data-value="4"]    { background: #ede0c8; color: var(--text-color-dark); }
        .tile[data-value="8"]    { background: #f2b179; color: var(--text-color-light); }
        .tile[data-value="16"]   { background: #f59563; color: var(--text-color-light); }
        .tile[data-value="32"]   { background: #f67c5f; color: var(--text-color-light); }
        .tile[data-value="64"]   { background: #f65e3b; color: var(--text-color-light); }
        .tile[data-value="128"]  { background: #edcf72; color: var(--text-color-light); }
        .tile[data-value="256"]  { background: #edcc61; color: var(--text-color-light); }
        .tile[data-value="512"]  { background: #edc850; color: var(--text-color-light); }
        .tile[data-value="1024"] { background: #edc53f; color: var(--text-color-light); }
        .tile[data-value="2048"] { background: #edc22e; color: var(--text-color-light); box-shadow: 0 0 20px 0px #edc22e; }
        .tile[data-value="4096"] { background: #3c3a32; color: var(--text-color-light); box-shadow: 0 0 30px 0px #3c3a32; }

        /* Overlay */
        .overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(238, 228, 218, 0.73);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 300ms ease-in-out;
        }
        .overlay.active { display: flex; opacity: 1; }
        .overlay h2 { font-size: 3rem; }
        .overlay .button-group { display: flex; gap: 15px; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="main-container">
        <div id="setup-screen">
            <h1>2048</h1>
            <h2>Choose your board size:</h2>
            <div id="size-options"></div>
        </div>

        <div id="game-area">
            <div class="header-container">
                <h1 class="title">2048</h1>
                <div class="controls-container" style="display: flex; gap: 10px;">
                    <div class="score-box">
                        <div class="label">SCORE</div>
                        <div id="score">0</div>
                    </div>
                    <div class="score-box">
                        <div class="label">BEST</div>
                        <div id="best-score">0</div>
                    </div>
                </div>
            </div>
            <div id="board-container"></div>
            <button id="menu-button" class="action-button" style="margin-top: 20px;">Back to Menu</button>
        </div>
    </div>

    <div id="game-over-overlay" class="overlay">
        <h2 id="overlay-message">Game Over!</h2>
        <p>Your final score: <span id="final-score">0</span></p>
        <div class="button-group">
            <button id="restart-button" class="action-button">Try Again</button>
            <button id="share-button" class="action-button">Share Score</button>
        </div>
    </div>

    <script>
        class Tile {
            constructor(value, x, y) {
                this.value = value || (Math.random() > 0.9 ? 4 : 2);
                this.x = x;
                this.y = y;
                this.element = this.createElement();
                this.update(true);
            }

            createElement() {
                const tile = document.createElement('div');
                tile.classList.add('tile');
                return tile;
            }

            update(isNew = false) {
                this.element.textContent = this.value;
                this.element.dataset.value = this.value;
                if(isNew) this.element.style.animation = 'appear 200ms ease';
            }

            merge() {
                this.element.style.animation = 'pop 200ms ease';
            }

            destroy() {
                this.element.remove();
            }
        }

        class Game {
            constructor(size) {
                this.size = size;
                this.score = 0;
                this.isWon = false;
                this.isMoving = false;
                this.bestScore = parseInt(localStorage.getItem('bestScore')) || 0;

                this.initDOM();
                this.initGrid();
                this.updateScore(0);
                this.updateBestScore();

                this.addRandomTile();
                this.addRandomTile();
            }

            initDOM() {
                this.boardContainer = document.getElementById('board-container');
                this.boardContainer.innerHTML = ''; // Clear previous board
                
                const boardRect = this.boardContainer.getBoundingClientRect();
                this.cellSize = (boardRect.width - (this.size + 1) * 15) / this.size; // 15 is grid-gap

                for (let i = 0; i < this.size * this.size; i++) {
                    const cell = document.createElement("div");
                    cell.classList.add("grid-cell");
                    cell.style.width = `${this.cellSize}px`;
                    cell.style.height = `${this.cellSize}px`;
                    this.boardContainer.appendChild(cell);
                }
            }

            initGrid() {
                this.grid = Array.from({ length: this.size }, () => Array(this.size).fill(null));
            }
            
            // --- Core Game Logic ---

            move(direction) {
                if (this.isMoving) return;
                this.isMoving = true;

                const firstPositions = this.recordPositions();
                const moveHappened = this.processMove(direction);

                if (moveHappened) {
                    this.animateMove(firstPositions);
                } else {
                    this.isMoving = false;
                }
            }

            processMove(direction) {
                let moved = false;
                const getLine = (i) => {
                    let line = [];
                    for(let j=0; j<this.size; j++) {
                        if (direction === 'left' || direction === 'right') line.push(this.grid[i][j]);
                        else line.push(this.grid[j][i]);
                    }
                    return line;
                };

                const setLine = (i, line) => {
                    for(let j=0; j<this.size; j++) {
                        if (direction === 'left' || direction === 'right') this.grid[i][j] = line[j];
                        else this.grid[j][i] = line[j];
                    }
                };

                for (let i = 0; i < this.size; i++) {
                    const line = getLine(i);
                    const originalLine = JSON.stringify(line.map(t => t ? t.value : 0));
                    
                    if (direction === 'right' || direction === 'down') line.reverse();

                    let current = 0;
                    let newLine = Array(this.size).fill(null);
                    
                    for (let j = 0; j < this.size; j++) {
                        if (line[j] === null) continue;
                        
                        if (newLine[current] === null) {
                            newLine[current] = line[j];
                        } else if (newLine[current].value === line[j].value) {
                            this.updateScore(newLine[current].value * 2);
                            newLine[current].value *= 2;
                            line[j].destroy(); // Remove merged tile from DOM
                            current++;
                        } else {
                            current++;
                            newLine[current] = line[j];
                        }
                    }

                    if (direction === 'right' || direction === 'down') newLine.reverse();
                    
                    if (JSON.stringify(newLine.map(t => t ? t.value : 0)) !== originalLine) {
                        moved = true;
                    }
                    setLine(i, newLine);
                }
                return moved;
            }

            addRandomTile() {
                const emptyCells = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === null) emptyCells.push({r, c});
                    }
                }
                if (emptyCells.length > 0) {
                    const {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.grid[r][c] = new Tile(null, c, r);
                }
            }

            // --- Animation (FLIP Technique) ---
            recordPositions() {
                const positions = new Map();
                for (const tile of this.grid.flat().filter(t => t)) {
                    positions.set(tile, tile.element.getBoundingClientRect());
                }
                return positions;
            }

            animateMove(firstPositions) {
                // LAST - Update the DOM to the final state
                this.render();

                // INVERT & PLAY
                for (const tile of this.grid.flat().filter(t => t)) {
                    const first = firstPositions.get(tile);
                    if (first) {
                        const last = tile.element.getBoundingClientRect();
                        const dx = first.left - last.left;
                        const dy = first.top - last.top;

                        if (dx !== 0 || dy !== 0) {
                            requestAnimationFrame(() => {
                                tile.element.style.transform = `translate(${dx}px, ${dy}px)`;
                                requestAnimationFrame(() => {
                                    tile.element.style.transform = '';
                                });
                            });
                        }
                    }
                }
                
                // After animation, cleanup and next turn
                setTimeout(() => {
                    this.grid.flat().filter(t => t).forEach(t => t.update());
                    this.addRandomTile();
                    this.render();
                    this.checkEndConditions();
                    this.isMoving = false;
                }, 100);
            }
            
            render() {
                 this.boardContainer.innerHTML = '';
                 for (let i = 0; i < this.size * this.size; i++) {
                    const cell = document.createElement("div");
                    cell.classList.add("grid-cell");
                    cell.style.width = `${this.cellSize}px`;
                    cell.style.height = `${this.cellSize}px`;
                    this.boardContainer.appendChild(cell);
                }

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        const tile = this.grid[r][c];
                        if (tile) {
                            tile.x = c;
                            tile.y = r;
                            const top = r * (this.cellSize + 15) + 15;
                            const left = c * (this.cellSize + 15) + 15;
                            tile.element.style.transform = '';
                            tile.element.style.top = `${top}px`;
                            tile.element.style.left = `${left}px`;
                            tile.element.style.width = `${this.cellSize}px`;
                            tile.element.style.height = `${this.cellSize}px`;
                            this.boardContainer.appendChild(tile.element);
                        }
                    }
                }
            }
            
            checkEndConditions() {
                // Check for win
                if (!this.isWon && this.grid.flat().some(t => t && t.value === 2048)) {
                    this.isWon = true;
                    showOverlay("You Win!", false);
                }
                // Check for lose
                if (!this.canMove()) {
                    showOverlay("Game Over!", true);
                }
            }
            
            canMove() {
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.grid[r][c] === null) return true;
                        if (c < this.size - 1 && this.grid[r][c].value === this.grid[r][c+1]?.value) return true;
                        if (r < this.size - 1 && this.grid[r][c].value === this.grid[r+1][c]?.value) return true;
                    }
                }
                return false;
            }

            updateScore(points) {
                this.score += points;
                document.getElementById('score').innerText = this.score;
                if(this.score > this.bestScore) {
                    this.bestScore = this.score;
                    localStorage.setItem('bestScore', this.bestScore);
                    this.updateBestScore();
                }
                if (navigator.vibrate) navigator.vibrate(10);
            }
            
            updateBestScore() {
                document.getElementById('best-score').innerText = this.bestScore;
            }
        }

        // --- Global State & Event Handling ---
        let game;
        const setupScreen = document.getElementById("setup-screen");
        const gameArea = document.getElementById("game-area");

        function init() {
            for (let i = 3; i <= 10; i++) {
                let button = document.createElement("button");
                button.classList.add("size-button");
                button.innerText = `${i}x${i}`;
                button.dataset.size = i;
                button.addEventListener('click', () => startGame(i));
                document.getElementById("size-options").append(button);
            }
            setupInputListeners();
        }

        function startGame(size) {
            document.documentElement.style.setProperty('--grid-size', size);
            document.documentElement.dataset.gridSize = size;
            setupScreen.style.display = 'none';
            gameArea.style.display = 'flex';
            game = new Game(size);
        }

        function showOverlay(message, isGameOver) {
            const overlay = document.getElementById('game-over-overlay');
            document.getElementById('overlay-message').textContent = message;
            document.getElementById('final-score').textContent = game.score;

            const shareButton = document.getElementById('share-button');
            shareButton.style.display = (isGameOver && navigator.share) ? 'block' : 'none';
            
            const restartButton = document.getElementById('restart-button');
            restartButton.textContent = isGameOver ? "Try Again" : "Keep Playing";
            
            overlay.classList.add('active');
            
            const closeOverlay = () => {
                overlay.classList.remove('active');
                if (isGameOver) startGame(game.size);
                restartButton.removeEventListener('click', closeOverlay);
            };
            restartButton.addEventListener('click', closeOverlay);
        }
        
        function setupInputListeners() {
            document.addEventListener('keydown', e => {
                if (gameArea.style.display === 'none' || !game) return;
                const map = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right' };
                if (map[e.key]) {
                    e.preventDefault();
                    game.move(map[e.key]);
                }
            });

            let touchStart = { x: 0, y: 0 };
            document.addEventListener('touchstart', e => {
                if (gameArea.style.display === 'none') return;
                touchStart.x = e.touches[0].clientX;
                touchStart.y = e.touches[0].clientY;
            }, { passive: true });

            document.addEventListener('touchend', e => {
                if (gameArea.style.display === 'none' || !game) return;
                const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
                const dx = touchEnd.x - touchStart.x;
                const dy = touchEnd.y - touchStart.y;
                if (Math.max(Math.abs(dx), Math.abs(dy)) > 50) {
                    game.move(Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up'));
                }
            });

            document.getElementById('menu-button').addEventListener('click', () => window.location.reload());
            
            document.getElementById('share-button').addEventListener('click', () => {
                if (navigator.share) {
                    navigator.share({
                        title: 'I scored in 2048!',
                        text: `I scored ${game.score} in 2048 on a ${game.size}x${game.size} board! Can you beat it?`,
                        url: window.location.href,
                    }).catch(console.error);
                }
            });
        }
        
        init();
    </script>
</body>
</html>
