<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>באבל של השטן</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffc107;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        h1 {
            font-size: 3em;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 10px;
        }
        #game-container {
            position: relative;
            border: 4px solid #ff5722;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.7);
            background-color: #2b2b2b;
        }
        canvas {
            display: block;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><g fill="%233a3a3a" fill-opacity="0.4"><rect x="50" width="50" height="50"/><rect y="50" width="50" height="50"/></g></svg>');
        }
        #info-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 20px;
            box-sizing: border-box;
            font-size: 1.5em;
        }
        #score, #misses-left {
            font-weight: bold;
        }
        #game-over-screen, #win-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
        }
        #game-over-screen h2, #win-screen h2 {
            font-size: 4em;
            margin: 0;
            color: #ff5722;
        }
        #game-over-screen p, #win-screen p {
            font-size: 1.5em;
            margin: 20px 0;
        }
        .restart-button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            border: 2px solid #ffc107;
            background-color: #ff5722;
            color: white;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .restart-button:hover {
            background-color: #ffc107;
            border-color: #ff5722;
            color: #1a1a1a;
        }
    </style>
</head>
<body>

    <h1>🔥 באבל של השטן 🔥</h1>
    
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="game-over-screen">
            <h2>הפסדת!</h2>
            <p>הכדורים הגיעו לתחתית.</p>
            <p id="final-score-lose"></p>
            <button class="restart-button" onclick="init()">שחק שוב</button>
        </div>
        <div id="win-screen">
            <h2>ניצחון מוחץ!</h2>
            <p>ניקית את כל הכדורים!</p>
            <p id="final-score-win"></p>
            <button class="restart-button" onclick="init()">שחק שוב</button>
        </div>
    </div>

    <div id="info-panel">
        <div id="score-display">ניקוד: <span id="score">0</span></div>
        <div id="misses-display">החטאות עד לשורה חדשה: <span id="misses-left">5</span></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winScreen = document.getElementById('win-screen');
        const scoreElement = document.getElementById('score');
        const missesLeftElement = document.getElementById('misses-left');
        const finalScoreLoseElement = document.getElementById('final-score-lose');
        const finalScoreWinElement = document.getElementById('final-score-win');

        // Game settings
        const BUBBLE_RADIUS = 20;
        const COLS = 15;
        const ROWS = 8;
        const BUBBLE_COLORS = ['#ff4136', '#ff851b', '#ffd700', '#2ecc40', '#0074d9', '#b10dc9'];
        const MISSES_ALLOWED = 5;

        let grid = [];
        let projectile;
        let nextProjectile;
        let score = 0;
        let misses = 0;
        let isShooting = false;
        let gameOver = false;
        
        // Devil shooter properties
        const devil = {
            x: 0,
            y: 0,
            angle: -Math.PI / 2
        };

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const width = COLS * BUBBLE_RADIUS * 2;
            const height = Math.min(window.innerHeight * 0.7, width * 1.2);
            canvas.width = width;
            canvas.height = height;
            container.style.width = `${width}px`;
            container.style.height = `${height}px`;
            
            devil.x = canvas.width / 2;
            devil.y = canvas.height - 30;
        }

        function init() {
            resizeCanvas();
            score = 0;
            misses = 0;
            isShooting = false;
            gameOver = false;
            gameOverScreen.style.display = 'none';
            winScreen.style.display = 'none';
            updateInfoPanel();
            createGrid();
            createProjectile();
            createProjectile(); // Create the 'next' one
            gameLoop();
        }

        function createGrid() {
            grid = [];
            for (let r = 0; r < ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (Math.random() > 0.3) {
                        grid[r][c] = {
                            x: c * BUBble_RADIUS * 2 + BUBBLE_RADIUS + (r % 2 === 1 ? BUBBLE_RADIUS : 0),
                            y: r * (BUBBLE_RADIUS * 2 - 5) + BUBBLE_RADIUS,
                            color: BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)],
                            radius: BUBBLE_RADIUS,
                            visible: true
                        };
                    } else {
                        grid[r][c] = null;
                    }
                }
            }
        }
        
        function getAvailableColors() {
            const colors = new Set();
            grid.flat().filter(b => b && b.visible).forEach(b => colors.add(b.color));
            return colors.size > 0 ? Array.from(colors) : BUBBLE_COLORS;
        }

        function createProjectile() {
            projectile = nextProjectile;
            const availableColors = getAvailableColors();
            const color = availableColors[Math.floor(Math.random() * availableColors.length)];
            nextProjectile = {
                x: devil.x,
                y: devil.y,
                color: color,
                radius: BUBBLE_RADIUS,
                dx: 0,
                dy: 0,
                speed: 15
            };
            if (!projectile) projectile = { ...nextProjectile, color: availableColors[Math.floor(Math.random() * availableColors.length)] };
        }

        function drawGrid() {
            grid.forEach(row => {
                row.forEach(bubble => {
                    if (bubble && bubble.visible) {
                        drawBubble(bubble);
                    }
                });
            });
        }
        
        function drawBubble(bubble) {
            ctx.beginPath();
            ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
            ctx.fillStyle = bubble.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.stroke();
            ctx.closePath();

            // Simple shine effect
            ctx.beginPath();
            ctx.arc(bubble.x - bubble.radius / 3, bubble.y - bubble.radius / 3, bubble.radius / 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.fill();
            ctx.closePath();
        }
        
        function drawDevilShooter() {
            const x = devil.x;
            const y = devil.y;
            
            // Devil Body (a simple shape)
            ctx.fillStyle = '#d90429';
            ctx.beginPath();
            ctx.moveTo(x, y - 25);
            ctx.bezierCurveTo(x - 30, y, x - 20, y + 20, x, y + 20);
            ctx.bezierCurveTo(x + 20, y + 20, x + 30, y, x, y - 25);
            ctx.fill();

            // Horns
            ctx.fillStyle = '#2b2b2b';
            ctx.beginPath();
            ctx.moveTo(x - 10, y - 20);
            ctx.quadraticCurveTo(x - 25, y - 40, x - 15, y - 15);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 10, y - 20);
            ctx.quadraticCurveTo(x + 25, y - 40, x + 15, y - 15);
            ctx.fill();

            // Draw Arrow (Trident)
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(devil.angle);
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 4;
            
            // Shaft
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -50);
            ctx.stroke();
            
            // Prongs
            ctx.beginPath();
            ctx.moveTo(0, -60);
            ctx.lineTo(-10, -50);
            ctx.lineTo(10, -50);
            ctx.closePath();
            ctx.fillStyle = '#ffc107';
            ctx.fill();

            ctx.restore();
            
            // Draw next projectile preview
            if (nextProjectile) {
                ctx.globalAlpha = 0.7;
                drawBubble({ ...nextProjectile, x: devil.x + 45, y: devil.y, radius: BUBBLE_RADIUS/2 });
                ctx.globalAlpha = 1.0;
            }
        }
        
        function drawProjectile() {
            if (isShooting && projectile) {
                drawBubble(projectile);
            }
        }

        function update() {
            if (gameOver) return;

            if (isShooting && projectile) {
                projectile.x += projectile.dx;
                projectile.y += projectile.dy;

                // Wall collision
                if (projectile.x - projectile.radius < 0 || projectile.x + projectile.radius > canvas.width) {
                    projectile.dx *= -1;
                }

                // Top collision
                if (projectile.y - projectile.radius < 0) {
                    snapProjectile({x: projectile.x, y: projectile.radius});
                    return;
                }

                // Bubble collision
                for (let r = 0; r < grid.length; r++) {
                    for (let c = 0; c < grid[r].length; c++) {
                        const bubble = grid[r][c];
                        if (bubble && bubble.visible) {
                            const dist = Math.hypot(projectile.x - bubble.x, projectile.y - bubble.y);
                            if (dist < projectile.radius + bubble.radius) {
                                snapProjectile(projectile);
                                return;
                            }
                        }
                    }
                }
            }
        }
        
        function snapProjectile(proj) {
            isShooting = false;
            
            let bestFit = { r: -1, c: -1, dist: Infinity };
            
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] === null) {
                         const bubbleX = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + (r % 2 === 1 ? BUBBLE_RADIUS : 0);
                         const bubbleY = r * (BUBBLE_RADIUS * 2 - 5) + BUBBLE_RADIUS;
                         const dist = Math.hypot(proj.x - bubbleX, proj.y - bubbleY);
                         
                         if(dist < BUBBLE_RADIUS * 2 && dist < bestFit.dist) {
                              let hasNeighbor = false;
                              const neighbors = getNeighbors({r, c});
                              for(const n of neighbors) {
                                  if(grid[n.r] && grid[n.r][n.c]) {
                                      hasNeighbor = true;
                                      break;
                                  }
                              }
                              if(hasNeighbor || r === 0) {
                                 bestFit = {r, c, dist};
                              }
                         }
                    }
                }
            }

            if (bestFit.r === -1) { // No empty spot found, try adding a new row
                addNewRow();
                bestFit.r = grid.length -1;
                let closestCol = Math.floor(proj.x / (BUBBLE_RADIUS * 2));
                bestFit.c = closestCol;
            }

            const {r, c} = bestFit;
            
            if (grid[r] === undefined) {
                grid[r] = [];
            }
            
            grid[r][c] = {
                x: c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + (r % 2 === 1 ? BUBBLE_RADIUS : 0),
                y: r * (BUBBLE_RADIUS * 2 - 5) + BUBBLE_RADIUS,
                color: projectile.color,
                radius: BUBBLE_RADIUS,
                visible: true
            };
            
            const matches = findMatches(r, c);
            if (matches.length >= 3) {
                matches.forEach(bubble => {
                    grid[bubble.r][bubble.c].visible = false;
                });
                score += matches.length * 10;
                
                const floating = findFloating();
                floating.forEach(bubble => {
                    grid[bubble.r][bubble.c].visible = false;
                    score += 20; // Bonus for dropping
                });
                
                misses = 0; // Reset misses on a successful match
            } else {
                misses++;
            }
            
            checkGameState();
            if (!gameOver) {
                createProjectile();
            }
        }

        function findMatches(startR, startC) {
            const targetColor = grid[startR][startC].color;
            const toVisit = [{ r: startR, c: startC }];
            const visited = new Set([`${startR},${startC}`]);
            const matches = [];

            while (toVisit.length > 0) {
                const current = toVisit.pop();
                matches.push(current);

                const neighbors = getNeighbors(current);
                neighbors.forEach(n => {
                    if (grid[n.r] && grid[n.r][n.c] && grid[n.r][n.c].visible && grid[n.r][n.c].color === targetColor && !visited.has(`${n.r},${n.c}`)) {
                        visited.add(`${n.r},${n.c}`);
                        toVisit.push(n);
                    }
                });
            }
            return matches;
        }
        
        function findFloating() {
            const connected = new Set();
            const toVisit = [];
            
            // All top row bubbles are connected
            for (let c = 0; c < COLS; c++) {
                if (grid[0][c] && grid[0][c].visible) {
                    toVisit.push({r: 0, c: c});
                    connected.add(`0,${c}`);
                }
            }
            
            while(toVisit.length > 0) {
                const current = toVisit.pop();
                const neighbors = getNeighbors(current);
                for(const n of neighbors) {
                    if (grid[n.r] && grid[n.r][n.c] && grid[n.r][n.c].visible && !connected.has(`${n.r},${n.c}`)) {
                        connected.add(`${n.r},${n.c}`);
                        toVisit.push(n);
                    }
                }
            }
            
            const floating = [];
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < COLS; c++) {
                    if(grid[r][c] && grid[r][c].visible && !connected.has(`${r},${c}`)) {
                        floating.push({r, c});
                    }
                }
            }
            return floating;
        }

        function getNeighbors({r, c}) {
            const isOddRow = r % 2 === 1;
            const neighborDefs = [
                { dr: 0, dc: -1 }, // Left
                { dr: 0, dc: 1 },  // Right
                { dr: -1, dc: 0 }, // Top middle
                { dr: 1, dc: 0 },  // Bottom middle
                { dr: -1, dc: isOddRow ? 1 : -1 }, // Top right/left
                { dr: 1, dc: isOddRow ? 1 : -1 }  // Bottom right/left
            ];
            const neighbors = [];
            neighborDefs.forEach(def => {
                const nr = r + def.dr;
                const nc = c + def.dc;
                if (nr >= 0 && nr < grid.length && nc >= 0 && nc < COLS) {
                    neighbors.push({ r: nr, c: nc });
                }
            });
            return neighbors;
        }
        
        function addNewRow() {
             grid.unshift(new Array(COLS).fill(null));
             for (let c = 0; c < COLS; c++) {
                 if(Math.random() > 0.3) {
                    grid[0][c] = {
                        x: c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS,
                        y: BUBBLE_RADIUS,
                        color: BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)],
                        radius: BUBBLE_RADIUS,
                        visible: true
                    };
                 }
             }
             
             // Shift all bubbles down
             for (let r = 1; r < grid.length; r++) {
                 for (let c = 0; c < COLS; c++) {
                     if (grid[r][c]) {
                         grid[r][c].y = r * (BUBBLE_RADIUS * 2 - 5) + BUBBLE_RADIUS;
                         grid[r][c].x = c * BUBBLE_RADIUS * 2 + BUBBLE_RADIUS + (r % 2 === 1 ? BUBBLE_RADIUS : 0);
                     }
                 }
             }
             misses = 0;
        }
        
        function checkGameState() {
            // Check for loss
            for (let c = 0; c < COLS; c++) {
                if(grid.length > 0) {
                   const lastRowIndex = grid.length - 1;
                   if (grid[lastRowIndex] && grid[lastRowIndex][c]) {
                       const bubble = grid[lastRowIndex][c];
                       if (bubble && bubble.visible && bubble.y + BUBBLE_RADIUS > canvas.height - 60) {
                           triggerGameOver(false);
                           return;
                       }
                   }
                }
            }
            
            // Check for win
            if (grid.flat().filter(b => b && b.visible).length === 0) {
                triggerGameOver(true);
                return;
            }

            // Add new row if misses are maxed
            if (misses >= MISSES_ALLOWED) {
                addNewRow();
            }
            
            updateInfoPanel();
        }
        
        function triggerGameOver(isWin) {
            gameOver = true;
            if (isWin) {
                finalScoreWinElement.textContent = `ניקוד סופי: ${score}`;
                winScreen.style.display = 'flex';
            } else {
                finalScoreLoseElement.textContent = `ניקוד סופי: ${score}`;
                gameOverScreen.style.display = 'flex';
            }
        }
        
        function updateInfoPanel() {
            scoreElement.textContent = score;
            missesLeftElement.textContent = MISSES_ALLOWED - misses;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawDevilShooter();
            drawProjectile();
        }

        function gameLoop() {
            update();
            draw();
            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        canvas.addEventListener('mousemove', (e) => {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const dx = mouseX - devil.x;
            const dy = mouseY - devil.y;
            let angle = Math.atan2(dy, dx) + Math.PI / 2;
            
            // Limit angle
            const minAngle = -Math.PI / 2 - 1.4;
            const maxAngle = -Math.PI / 2 + 1.4;
            if(angle > 0) angle = Math.PI - angle; // Correct angle when mouse is below shooter
            devil.angle = Math.max(minAngle, Math.min(maxAngle, angle));
        });

        canvas.addEventListener('click', (e) => {
            if (isShooting || gameOver) return;
            isShooting = true;
            projectile.dx = Math.sin(devil.angle) * projectile.speed;
            projectile.dy = -Math.cos(devil.angle) * projectile.speed;
        });
        
        window.addEventListener('resize', () => {
            // A simple debounce to avoid excessive resizing calls
            setTimeout(() => {
                resizeCanvas();
                // We might need to reposition bubbles after resize, but for simplicity we restart
                init();
            }, 250);
        });

        // Start the game
        init();
    </script>

</body>
</html>
