<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>  砖 砖 </title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #ff5722;
            --secondary-color: #ffc107;
            --text-color: #f0f0f0;
            --border-color: #ff5722;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Arial', sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent; /* 注  爪  */
        }

        h1 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            text-shadow: 2px 2px 4px #000;
            margin: 10px 0;
            color: var(--secondary-color);
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px; /* 专 拽住 住  */
        }

        #game-container {
            position: relative;
            border: 4px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.7);
            background-color: #2b2b2b;
            touch-action: none; /* 注  砖 驻驻  砖拽 */
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 6px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* 住转专 专专转  */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            padding: 20px;
            box-sizing: border-box;
        }

        .overlay h2 {
            font-size: clamp(2.5rem, 10vw, 4rem);
            margin: 0;
            color: var(--primary-color);
            text-shadow: 2px 2px 5px black;
        }

        .overlay p {
            font-size: clamp(1rem, 4vw, 1.5rem);
            margin: 20px 0;
        }

        .restart-button {
            padding: 15px 30px;
            font-size: clamp(1rem, 5vw, 1.2rem);
            cursor: pointer;
            border: 2px solid var(--secondary-color);
            background-color: var(--primary-color);
            color: white;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .restart-button:hover, .restart-button:active {
            background-color: var(--secondary-color);
            border-color: var(--primary-color);
            color: var(--bg-color);
            transform: scale(1.05);
        }

        #info-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 10px 0;
            font-size: clamp(0.9rem, 4vw, 1.2rem);
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>  砖 砖 </h1>
    
    <div id="game-wrapper">
        <div id="info-panel">
            <div id="score-display">拽: <span id="score">0</span></div>
            <div id="misses-display">转: <span id="misses-left">5</span></div>
        </div>
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>
            <div id="game-over-screen" class="overlay">
                <h2>驻住转!</h2>
                <p>专 注 转转转.</p>
                <p id="final-score-lose"></p>
                <button class="restart-button">砖拽 砖</button>
            </div>
            <div id="win-screen" class="overlay">
                <h2>爪 抓!</h2>
                <p>拽转 转  专!</p>
                <p id="final-score-win"></p>
                <button class="restart-button">砖拽 砖</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('game-container');
            
            const gameOverScreen = document.getElementById('game-over-screen');
            const winScreen = document.getElementById('win-screen');
            const scoreElement = document.getElementById('score');
            const missesLeftElement = document.getElementById('misses-left');
            const finalScoreLoseElement = document.getElementById('final-score-lose');
            const finalScoreWinElement = document.getElementById('final-score-win');
            
            // Game settings
            const COLS = 12;
            const START_ROWS = 7;
            const MISSES_ALLOWED = 5;
            const BUBBLE_COLORS = ['#ff4136', '#ff851b', '#ffd700', '#2ecc40', '#0074d9', '#b10dc9'];
            
            let BUBBLE_RADIUS;
            let BUBBLE_DIAMETER;
            let ROW_HEIGHT;

            let grid = [];
            let projectile;
            let nextProjectile;
            let score = 0;
            let misses = 0;
            let isShooting = false;
            let gameOver = false;
            
            const devil = { x: 0, y: 0, angle: -Math.PI / 2 };

            function setCanvasDimensions() {
                const containerWidth = container.clientWidth;
                BUBBLE_DIAMETER = containerWidth / COLS;
                BUBBLE_RADIUS = BUBBLE_DIAMETER / 2;
                ROW_HEIGHT = BUBBLE_DIAMETER * 0.866; // Based on hexagon packing

                canvas.width = containerWidth;
                canvas.height = window.innerHeight * 0.7;
                
                devil.x = canvas.width / 2;
                devil.y = canvas.height - BUBBLE_RADIUS * 2.5;
            }

            function init() {
                setCanvasDimensions();
                score = 0;
                misses = 0;
                isShooting = false;
                gameOver = false;
                gameOverScreen.style.display = 'none';
                winScreen.style.display = 'none';
                updateInfoPanel();
                createGrid();
                createProjectile(); // Creates 'nextProjectile'
                createProjectile(); // Moves 'next' to 'current' and creates new 'next'
                requestAnimationFrame(gameLoop);
            }

            function createGrid() {
                grid = [];
                for (let r = 0; r < START_ROWS; r++) {
                    const row = [];
                    const colsInRow = (r % 2 === 0) ? COLS : COLS - 1;
                    for (let c = 0; c < colsInRow; c++) {
                         if (Math.random() > 0.1) {
                            row.push({
                                color: BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)],
                                visible: true,
                                r: r, c: c
                            });
                        } else {
                            row.push(null);
                        }
                    }
                    grid.push(row);
                }
                updateBubblePositions();
            }

            function updateBubblePositions() {
                for (let r = 0; r < grid.length; r++) {
                    const colsInRow = (r % 2 === 0) ? COLS : COLS - 1;
                    for (let c = 0; c < colsInRow; c++) {
                        if (grid[r][c]) {
                            grid[r][c].x = (r % 2 === 0) ? c * BUBBLE_DIAMETER + BUBBLE_RADIUS : c * BUBBLE_DIAMETER + BUBBLE_DIAMETER;
                            grid[r][c].y = r * ROW_HEIGHT + BUBBLE_RADIUS;
                        }
                    }
                }
            }

            function getAvailableColors() {
                const colors = new Set();
                grid.flat().filter(b => b && b.visible).forEach(b => colors.add(b.color));
                return colors.size > 0 ? Array.from(colors) : BUBBLE_COLORS.slice(0, 3);
            }

            function createProjectile() {
                projectile = nextProjectile;
                const availableColors = getAvailableColors();
                const color = availableColors[Math.floor(Math.random() * availableColors.length)];
                nextProjectile = {
                    x: devil.x, y: devil.y,
                    color: color,
                    dx: 0, dy: 0,
                    speed: canvas.height / 40
                };
                if (!projectile) { // First run
                    projectile = { ...nextProjectile, color: availableColors[Math.floor(Math.random() * availableColors.length)] };
                }
            }

            function drawBubble(bubble) {
                if (!bubble) return;
                ctx.beginPath();
                ctx.arc(bubble.x, bubble.y, BUBBLE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = bubble.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.stroke();
                // Shine effect
                ctx.beginPath();
                ctx.arc(bubble.x - BUBBLE_RADIUS / 3, bubble.y - BUBBLE_RADIUS / 3, BUBBLE_RADIUS / 4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                grid.flat().forEach(bubble => {
                    if (bubble && bubble.visible) drawBubble(bubble);
                });
                drawDevilShooter();
                if (isShooting && projectile) drawBubble(projectile);
            }
            
            function drawDevilShooter() {
                const x = devil.x; const y = devil.y;
                // Devil Body
                ctx.fillStyle = '#d90429'; ctx.beginPath();
                ctx.moveTo(x, y - BUBBLE_RADIUS); ctx.bezierCurveTo(x - BUBBLE_RADIUS * 1.5, y, x - BUBBLE_RADIUS, y + BUBBLE_RADIUS, x, y + BUBBLE_RADIUS);
                ctx.bezierCurveTo(x + BUBBLE_RADIUS, y + BUBBLE_RADIUS, x + BUBBLE_RADIUS * 1.5, y, x, y - BUBBLE_RADIUS); ctx.fill();
                
                // Draw current projectile in position
                if (!isShooting && projectile) drawBubble({ ...projectile, x: x, y: y });

                // Draw aiming line
                ctx.save(); ctx.beginPath(); ctx.moveTo(x, y);
                ctx.lineTo(x + Math.sin(devil.angle) * (canvas.height), y - Math.cos(devil.angle) * (canvas.height));
                ctx.setLineDash([5, 10]); ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.stroke(); ctx.restore();

                // Draw next projectile preview
                if (nextProjectile) {
                    ctx.globalAlpha = 0.8;
                    drawBubble({ ...nextProjectile, x: BUBBLE_RADIUS * 2, y: devil.y, radius: BUBBLE_RADIUS / 1.5 });
                    ctx.globalAlpha = 1.0;
                }
            }
            
            function update() {
                if (gameOver || !isShooting || !projectile) return;
                
                projectile.x += projectile.dx;
                projectile.y += projectile.dy;

                if (projectile.x - BUBBLE_RADIUS < 0 || projectile.x + BUBBLE_RADIUS > canvas.width) { projectile.dx *= -1; }
                if (projectile.y - BUBBLE_RADIUS < 0) { snapProjectile(projectile); return; }

                for (let r = 0; r < grid.length; r++) {
                    const colsInRow = (r % 2 === 0) ? COLS : COLS - 1;
                    for (let c = 0; c < colsInRow; c++) {
                        const bubble = grid[r][c];
                        if (bubble && bubble.visible) {
                            if (Math.hypot(projectile.x - bubble.x, projectile.y - bubble.y) < BUBBLE_DIAMETER * 0.9) {
                                snapProjectile(projectile); return;
                            }
                        }
                    }
                }
            }
            
            function snapProjectile(proj) {
                isShooting = false;
                
                const gridR = Math.round((proj.y - BUBBLE_RADIUS) / ROW_HEIGHT);
                const colsInRow = (gridR % 2 === 0) ? COLS : COLS - 1;
                let gridC;
                if(gridR % 2 === 0){
                    gridC = Math.round((proj.x - BUBBLE_RADIUS) / BUBBLE_DIAMETER);
                } else {
                    gridC = Math.round((proj.x - BUBBLE_DIAMETER) / BUBBLE_DIAMETER);
                }
                
                if (gridR < 0) gridR = 0;
                if (gridC < 0) gridC = 0;
                if (gridC >= colsInRow) gridC = colsInRow - 1;
                
                while(grid.length <= gridR) { grid.push(new Array((grid.length % 2 === 0) ? COLS : COLS - 1).fill(null)); }
                if(grid[gridR][gridC]){
                    // Simple collision resolution: find nearest empty slot
                    let found = false;
                    for (let i = -1; i <= 1 && !found; i++) {
                        for (let j = -1; j <= 1 && !found; j++) {
                            const newR = gridR + i;
                            const newC = gridC + j;
                            if (newR >= 0 && newR < grid.length && newC >= 0 && newC < grid[newR].length && !grid[newR][newC]) {
                                gridR = newR; gridC = newC; found = true;
                            }
                        }
                    }
                }

                grid[gridR][gridC] = { color: proj.color, visible: true, r: gridR, c: gridC };
                updateBubblePositions();

                const matches = findMatches(gridR, gridC);
                if (matches.length >= 3) {
                    matches.forEach(b => { grid[b.r][b.c].visible = false; });
                    score += matches.length * 10;
                    
                    const floating = findFloating();
                    floating.forEach(b => {
                        grid[b.r][b.c].visible = false;
                        score += 20;
                    });
                    misses = 0;
                } else {
                    misses++;
                }
                checkGameState();
                if (!gameOver) createProjectile();
            }
            
            function getNeighbors(r, c) {
                const isEvenRow = r % 2 === 0;
                const neighborDefs = [
                    { dr: 0, dc: -1 }, { dr: 0, dc: 1 }, // Left, Right
                    { dr: -1, dc: isEvenRow ? -1 : 0 }, { dr: -1, dc: isEvenRow ? 0 : 1 }, // Top-Left, Top-Right
                    { dr: 1, dc: isEvenRow ? -1 : 0 }, { dr: 1, dc: isEvenRow ? 0 : 1 }  // Bottom-Left, Bottom-Right
                ];
                const neighbors = [];
                neighborDefs.forEach(def => {
                    const nr = r + def.dr; const nc = c + def.dc;
                    if (nr >= 0 && nr < grid.length && nc >= 0 && grid[nr] && nc < grid[nr].length) {
                        neighbors.push({ r: nr, c: nc });
                    }
                });
                return neighbors;
            }

            function findMatches(startR, startC) {
                if (!grid[startR] || !grid[startR][startC]) return [];
                const targetColor = grid[startR][startC].color;
                const toVisit = [{ r: startR, c: startC }];
                const visited = new Set([`${startR},${startC}`]);
                const matches = [];

                while (toVisit.length > 0) {
                    const current = toVisit.pop();
                    matches.push(current);
                    getNeighbors(current.r, current.c).forEach(n => {
                        if (grid[n.r][n.c] && grid[n.r][n.c].visible && grid[n.r][n.c].color === targetColor && !visited.has(`${n.r},${n.c}`)) {
                            visited.add(`${n.r},${n.c}`);
                            toVisit.push(n);
                        }
                    });
                }
                return matches;
            }
            
            function findFloating() {
                const connected = new Set();
                const toVisit = [];
                if (grid[0]) {
                    grid[0].forEach((bubble, c) => {
                        if (bubble && bubble.visible) {
                            toVisit.push({ r: 0, c: c });
                            connected.add(`0,${c}`);
                        }
                    });
                }
                while(toVisit.length > 0) {
                    const current = toVisit.pop();
                    getNeighbors(current.r, current.c).forEach(n => {
                        if (grid[n.r][n.c] && grid[n.r][n.c].visible && !connected.has(`${n.r},${n.c}`)) {
                            connected.add(`${n.r},${n.c}`); toVisit.push(n);
                        }
                    });
                }
                const floating = [];
                for (let r = 0; r < grid.length; r++) {
                    for (let c = 0; c < grid[r].length; c++) {
                        if(grid[r][c] && grid[r][c].visible && !connected.has(`${r},${c}`)) {
                            floating.push({r, c});
                        }
                    }
                }
                return floating;
            }
            
            function addNewRow() {
                const newRow = [];
                for (let c = 0; c < COLS; c++) {
                    newRow.push({
                        color: BUBBLE_COLORS[Math.floor(Math.random() * BUBBLE_COLORS.length)],
                        visible: true
                    });
                }
                grid.unshift(newRow);
                misses = 0;
                updateBubblePositions();
            }

            function checkGameState() {
                // Loss condition
                const lastBubble = grid.flat().filter(b => b && b.visible).sort((a,b) => b.y - a.y)[0];
                if (lastBubble && lastBubble.y + BUBBLE_RADIUS >= devil.y - BUBBLE_RADIUS*2) {
                    triggerGameOver(false); return;
                }
                // Win condition
                if (grid.flat().filter(b => b && b.visible).length === 0) {
                    triggerGameOver(true); return;
                }
                if (misses >= MISSES_ALLOWED) addNewRow();
                updateInfoPanel();
            }

            function triggerGameOver(isWin) {
                gameOver = true;
                if (isWin) {
                    finalScoreWinElement.textContent = `拽 住驻: ${score}`;
                    winScreen.style.display = 'flex';
                } else {
                    finalScoreLoseElement.textContent = `拽 住驻: ${score}`;
                    gameOverScreen.style.display = 'flex';
                }
            }

            function updateInfoPanel() {
                scoreElement.textContent = score;
                missesLeftElement.textContent = `${MISSES_ALLOWED - misses}`;
            }

            function gameLoop() {
                update();
                draw();
                if (!gameOver) requestAnimationFrame(gameLoop);
            }

            function handleAim(x, y) {
                if (gameOver || y > devil.y) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = x - rect.left; const mouseY = y - rect.top;
                let angle = Math.atan2(mouseY - devil.y, mouseX - devil.x) + Math.PI / 2;
                const minAngle = -Math.PI / 2 - 1.45; const maxAngle = -Math.PI / 2 + 1.45;
                devil.angle = Math.max(minAngle, Math.min(maxAngle, angle));
            }

            function handleShoot() {
                if (isShooting || gameOver) return;
                isShooting = true;
                projectile.dx = Math.sin(devil
